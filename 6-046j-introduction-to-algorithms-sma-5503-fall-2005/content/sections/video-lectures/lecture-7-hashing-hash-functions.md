---
about_this_resource_text: <p><strong>Topics covered:</strong>&nbsp;Hashing, Hash Functions</p>
  <p><strong>Instructors:</strong>&nbsp;Prof. Erik Demaine,&nbsp;Prof. Charles Leiserson</p>
course_id: 6-046j-introduction-to-algorithms-sma-5503-fall-2005
embedded_media:
- id: lec7.pdf
  parent_uid: 038082bddaf2cd718a96f35effebed99
  technical_location: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-7-hashing-hash-functions/lec7.pdf
  title: lec7.pdf
  type: null
  uid: ce6ea57dd298c8e64609802daf2eaaec
- id: 6_046J_lec07_th.jpg
  parent_uid: 038082bddaf2cd718a96f35effebed99
  technical_location: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-7-hashing-hash-functions/6_046J_lec07_th.jpg
  title: 6_046J_lec07_th.jpg
  type: null
  uid: ee4a56d3393e654de1bd8c4bddaa8bfc
- id: Video-YouTube-Stream
  media_location: JZHBa-rLrBA
  parent_uid: 038082bddaf2cd718a96f35effebed99
  title: Video-YouTube-Stream
  type: Video
  uid: 435e5a1eb45c413e59e550c3172cd1a8
- id: Thumbnail-YouTube-JPG
  media_location: https://img.youtube.com/vi/JZHBa-rLrBA/default.jpg
  parent_uid: 038082bddaf2cd718a96f35effebed99
  title: Thumbnail-YouTube-JPG
  type: Thumbnail
  uid: f71dc4a982bb55808f71f57a89bb09ca
- id: Video-iTunesU-MP4
  media_location: https://itunes.apple.com/us/itunes-u/id341597754
  parent_uid: 038082bddaf2cd718a96f35effebed99
  title: Video-iTunes U-MP4
  type: Video
  uid: a65a54bcd820cf82aa5fbaf907d65fbf
- id: Video-InternetArchive-MP4
  media_location: http://www.archive.org/download/MIT6.046JF05MPEG4/ocw-6.046-03oct2005-220k.mp4
  parent_uid: 038082bddaf2cd718a96f35effebed99
  title: Video-Internet Archive-MP4
  type: Video
  uid: 0754fd791df462e5666a7ad995a8fd2e
- id: Video-iTunesU-MP3
  media_location: http://deimos3.apple.com/WebObjects/Core.woa/Browse/mit.edu.1298167185.01298167189.1303092513?i=1610478786
  parent_uid: 038082bddaf2cd718a96f35effebed99
  title: Video-iTunes U-MP3
  type: Video
  uid: 66a21f0cd3969e35adff336f03432598
- id: Video-InternetArchive-MP3
  media_location: http://www.archive.org/download/MIT6.046JF05/ocw-6.046-03oct2005.mp3
  parent_uid: 038082bddaf2cd718a96f35effebed99
  title: Video-Internet Archive-MP3
  type: Video
  uid: d8a112449acf00c6d8d0dbd86fb36abd
- id: Video-VideoLecturesnet-Stream
  media_location: http://videolectures.net/mit6046jf05_introduction_algorithms/
  parent_uid: 038082bddaf2cd718a96f35effebed99
  title: Video-VideoLectures.net-Stream
  type: Video
  uid: 3691fb7944d8f806ea520750a84a0707
- id: Thumbnail-OCW-JPG
  parent_uid: 038082bddaf2cd718a96f35effebed99
  title: Thumbnail-OCW-JPG
  type: Thumbnail
  uid: eda38c33ed56ada5ee965933e5e6f45f
- id: 3Play-3PlayYouTubeid-MP4
  media_location: JZHBa-rLrBA
  parent_uid: 038082bddaf2cd718a96f35effebed99
  title: 3Play-3Play YouTube id
  type: 3Play
  uid: 02a5d85395edc07ed9b473d9902d6b71
- id: JZHBa-rLrBA.srt
  parent_uid: 038082bddaf2cd718a96f35effebed99
  technical_location: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-7-hashing-hash-functions/JZHBa-rLrBA.srt
  title: 3play caption file
  type: null
  uid: 1051c08e8a32dc411190b515ab067aaa
- id: JZHBa-rLrBA.pdf
  parent_uid: 038082bddaf2cd718a96f35effebed99
  technical_location: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-7-hashing-hash-functions/JZHBa-rLrBA.pdf
  title: 3play pdf file
  type: null
  uid: 743bc0ec5bc92fec95817296f3536a97
- id: Caption-3Play YouTube id-SRT
  parent_uid: 038082bddaf2cd718a96f35effebed99
  title: Caption-3Play YouTube id-SRT-English - US
  type: Caption
  uid: 673987ae3026e11b6d1556450303fdbd
- id: Transcript-3Play YouTube id-PDF
  parent_uid: 038082bddaf2cd718a96f35effebed99
  title: Transcript-3Play YouTube id-PDF-English - US
  type: Transcript
  uid: 1ece2370ea70b11e872331f85cd0abfd
inline_embed_id: 11320273lecture7:hashing,hashfunctions43783821
layout: video
order_index: null
parent_uid: c492612542f7cc7a09f73790a5f91d81
related_resources_text: <p>Lecture Notes (<a target="_blank" href="./resolveuid/ce6ea57dd298c8e64609802daf2eaaec">PDF</a>)<br
  />             <a target="_blank" href="./resolveuid/efc69ef86c18e164d675bd8808c6477a">Assignments</a><br
  />             <a target="_blank" href="./resolveuid/144d9e513546eac8c1fd9b0d278e6eb2">Exams</a></p>
short_url: lecture-7-hashing-hash-functions
technical_location: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-7-hashing-hash-functions
template_type: Tabbed
title: 'Lecture 7: Hashing, Hash Functions'
transcript: '<p><span m=''9000''>Today starts a two-lecture sequence on the topic
  of</span> <span m=''15000''>hashing, which is a really great technique that shows
  up in a lot</span> <span m=''23000''>of places. So we''re going to introduce it</span>
  <span m=''28000''>through a problem that comes up often in compilers called the</span>
  <span m=''36000''>symbol table problem. And the idea is that we have a</span> <span
  m=''45000''>table S holding n records where each record, just to be a little</span>
  <span m=''57000''>more explicit here. So each record typically has a</span> <span
  m=''65000''>bunch of, this is record x. x is usually a pointer to the</span> <span
  m=''70000''>actual data. So when we talk about the</span> <span m=''74000''>record
  x, what it usually means some pointer to the data.</span> </p><p><span m=''80000''>And
  in the data, in the record,</span> <span m=''83000''>so this is a record, there
  is a key called a key of</span> <span m=''88000''>x. In some languages it''s key,</span>
  <span m=''92000''>it''s x dot key or x arrow key, OK, are other ways that that</span>
  <span m=''98000''>will be denoted in some languages.</span> </p><p><span m=''101000''>And
  there''s usually some additional data called satellite</span> <span m=''106000''>data,
  which is carried around with the key.</span> </p><p><span m=''110000''>This is also
  true in sorting, but usually you''re sorting</span> <span m=''116000''>records.
  You''re not sorting individual</span> <span m=''119000''>keys. And so the idea is
  that we have</span> <span m=''123000''>a bunch of operations that we would like
  to do on this data on</span> <span m=''129000''>this table. So we want to be able
  to insert</span> <span m=''135000''>an item x into the table, which just essentially
  means</span> <span m=''140000''>that we update the table by adding the element x.</span>
  </p><p><span m=''145000''>We want to be able to delete an item from the table --</span>
  <span m=''158000''>-- so removing the item x from the set and we want to be able</span>
  <span m=''168000''>to search for a given key. So this returns the value x</span>
  <span m=''177000''>such that key of x is equal to k, where it returns nil if</span>
  <span m=''186000''>there''s no such x. So be able to insert items in,</span> <span
  m=''193000''>delete them and also look to see if there''s an item that has</span>
  <span m=''198000''>a particular key. So notice that delete doesn''t</span> <span
  m=''202000''>take a key. Delete takes a record.</span> </p><p><span m=''205000''>OK,
  so if you want to delete something of a particular key</span> <span m=''210000''>and
  you don''t happen to have a pointer to it,</span> <span m=''214000''>you have to
  say let me search for it and then delete it.</span> </p><p><span m=''220000''>So
  these, whenever you have a set operations,</span> <span m=''224000''>where operations
  that change the set like in certain delete,</span> <span m=''231000''>we call it
  a dynamic set. So these two operations make</span> <span m=''237000''>the set dynamic.
  It changes over time.</span> </p><p><span m=''241000''>Sometimes you want to build
  a fixed data structure.</span> </p><p><span m=''244000''>It''s going to be a static
  set. All you''re going to do is do</span> <span m=''248000''>things like look it
  up and so forth.</span> </p><p><span m=''251000''>But most often, it turns out that
  in</span> <span m=''253000''>programming and so forth, we want to have the set be</span>
  <span m=''257000''>dynamic. Want to be able to add elements</span> <span m=''259000''>to
  it, delete elements to it and so forth.</span> </p><p><span m=''262000''>And there
  may be other operations that modify the set,</span> <span m=''266000''>modify membership
  in the set. So the simplest implementation</span> <span m=''270000''>for this is
  actually often overlooked.</span> </p><p><span m=''274000''>I''m actually surprised
  how often people use more</span> <span m=''276000''>complicated data structures
  when this simple data structure will</span> <span m=''280000''>work. It''s called
  a direct access</span> <span m=''282000''>table. Doesn''t always work.</span> </p><p><span
  m=''284000''>I''ll give the conditions where it does.</span> </p><p><span m=''293000''>So
  it works when the keys are drawn from our small</span> <span m=''298000''>distribution.
  So suppose the keys are drawn</span> <span m=''304000''>from a set U of m elements.
  OK, zero to m minus one.</span> </p><p><span m=''311000''>And we''re going to assume
  the keys are distinct.</span> </p><p><span m=''328000''>So the way a direct access
  table works is that you set up</span> <span m=''332000''>an array T --</span> <span
  m=''341000''>-- from zero to m minus one to represent the dynamic set S --</span>
  <span m=''358000''>-- such that T of k is going to be equal to x if x is in the
  set</span> <span m=''370000''>and its key is k and nil otherwise.</span> </p><p><span
  m=''384000''>So you just simply have an array and if you have a record</span> <span
  m=''390000''>whose key is some value k, the key is 15 say,</span> <span m=''395000''>then
  slot 15 if the element is there has the element.</span> </p><p><span m=''402000''>And
  if it''s not in the set, it''s nil.</span> </p><p><span m=''404000''>Very simple
  data structure. OK, insertion.</span> </p><p><span m=''408000''>Just go to that
  location and set the value to the inserted</span> <span m=''412000''>value. For
  deletion,</span> <span m=''414000''>just remove it from there. And to look it up,</span>
  <span m=''417000''>you just index it and see what''s in that slot.</span> </p><p><span
  m=''422000''>OK, very simple data structure. All these operations,</span> <span
  m=''429000''>therefore, take constant time in the worst case.</span> </p><p><span
  m=''435000''>But as a practical matter, the places you can use this</span> <span
  m=''443000''>strategy are pretty limited. What''s the issue of limitation</span>
  <span m=''451000''>here? Yes.</span> </p><p><span m=''458000''>OK, so that''s a
  limitation surely.</span> </p><p><span m=''461000''>But there''s actually a more
  severe limitation.</span> </p><p><span m=''465000''>Yeah. What does that mean,</span>
  <span m=''468000''>it''s hard to draw?</span> </p><p></p><p><span m=''485000''>No.
  Yeah. m minus one could be a huge number.</span> </p><p><span m=''489000''>Like
  for example, suppose that I want to have my</span> <span m=''494000''>set drawn
  over 64 bit values. OK, the things that I''m storing</span> <span m=''501000''>in
  my table is a set of 64-bit numbers.</span> </p><p><span m=''505000''>And so, maybe
  a small set. Maybe we only have a few</span> <span m=''510000''>thousand of these
  elements. But they''re drawn from a 64-bit</span> <span m=''517000''>value. Then
  this strategy requires me</span> <span m=''521000''>to have an array that goes from
  zero to 2 to the 64th minus one.</span> </p><p><span m=''527000''>How big is 2^64
  minus one? Approximately?</span> </p><p><span m=''531000''>It''s like big. It''s
  like 18 quintillion or</span> <span m=''535000''>something. I mean, it''s zillions
  literally</span> <span m=''539000''>because it''s like it''s beyond the illions
  we normally use.</span> </p><p><span m=''546000''>Not a billion or a trillion. It''s
  18 quintillion.</span> </p><p><span m=''549000''>OK, so that''s a really big number.</span>
  </p><p><span m=''552000''>So, or even worse, suppose the keys were drawn</span>
  <span m=''556000''>from character strings, so people''s names or something.</span>
  </p><p><span m=''560000''>This would be an awful way to have to represent it.</span>
  </p><p><span m=''564000''>Because most of the table would be empty for any reasonable
  set</span> <span m=''569000''>of values you would want to keep.</span> </p><p><span
  m=''573000''>So the idea is we want to try to keep something that''s going</span>
  <span m=''580000''>to keep the table small, while still preserving some of</span>
  <span m=''587000''>the properties. And that''s where hashing comes</span> <span
  m=''593000''>in. So hashing is we use a hash</span> <span m=''596000''>function
  H which maps the keys randomly.</span> </p><p><span m=''603000''>And I''m putting
  that in quotes because it''s not quite at</span> <span m=''608000''>random. Into
  slots table T.</span> </p><p><span m=''611000''>So we call each of the array indexes
  here a slot.</span> </p><p><span m=''616000''>So you can just sort of think of it
  as a big table and you''ve</span> <span m=''623000''>got slots in the table where
  you''re storing your values.</span> </p><p><span m=''630000''>And so, we may have
  a big universe of keys.</span> </p><p><span m=''634000''>Let''s call that U. And
  we have our table over here</span> <span m=''639000''>that we''ve set up that has
  --</span> <span m=''650000''>-- m slots.</span> </p><p><span m=''656000''>And so
  we actually have then a set that we''re actually going to</span> <span m=''662000''>try
  to represent S, which is presumably a very</span> <span m=''667000''>small piece
  of the universe. And what we''ll do is we''ll take</span> <span m=''673000''>an
  element from here and map it to let''s say to there and take</span> <span m=''678000''>another
  one and we apply the hash function to the element.</span> </p><p><span m=''683000''>And
  what the hash function is going to give us is it''s going</span> <span m=''688000''>to
  give us a particular slot. Here''s one that might go up</span> <span m=''694000''>here.
  Might have another one over</span> <span m=''697000''>here that goes down to there.
  And so, we get it to distribute</span> <span m=''704000''>the elements over the
  table. So what''s the problem that''s</span> <span m=''711000''>going to occur as
  we do this? So far, I''ve been a little bit</span> <span m=''718000''>lucky. What''s
  the problem potentially</span> <span m=''721000''>going to be?</span> </p><p><span
  m=''729000''>Yeah, when two things are in S, more specifically,</span> <span m=''731000''>get
  assigned to the same value. So I may have a guy here and he</span> <span m=''735000''>gets
  mapped to the same slot that somebody else has already</span> <span m=''738000''>been
  mapped to. And when this happens,</span> <span m=''741000''>we call that a collision.</span>
  </p><p><span m=''749000''>So we''re trying to map these things down into a small
  set but</span> <span m=''753000''>we could get unlucky in our mapping, particularly
  if we map</span> <span m=''758000''>enough of these guys. They''re not going to
  fit.</span> </p><p><span m=''761000''>So when a record --</span> <span m=''774000''>--
  to be inserted maps to an already occupied slot --</span> <span m=''799000''>--
  a collision occurs.</span> </p><p><span m=''812000''>OK. So looks like this method''s
  no</span> <span m=''814000''>good. But no, there''s a pretty simple</span> <span
  m=''817000''>thing we can do. What should we do when two</span> <span m=''820000''>things
  map to the same slot? If we want to represent the</span> <span m=''824000''>whole
  set, but you can''t lose any data, can''t treat it like a</span> <span m=''829000''>cache.
  In a cache what you do is it</span> <span m=''832000''>uses a hashing scheme, but
  in a cache,</span> <span m=''834000''>you just kick it out because you don''t care
  about</span> <span m=''838000''>representing a set precisely. But in a hash table
  you''re</span> <span m=''844000''>programming, you often want to make sure that
  the values you</span> <span m=''848000''>have are exactly the values in the sets
  so you can tell whether</span> <span m=''854000''>something belongs to the set or
  not.</span> </p><p><span m=''856000''>So what''s a good strategy here? Yeah.</span>
  </p><p><span m=''859000''>Create a list for each slot and just put all the elements
  that</span> <span m=''864000''>hash to the same slot into the list.</span> </p><p><span
  m=''867000''>And that''s called resolving collisions by chaining.</span> </p><p><span
  m=''878000''>And the idea is to link records in the same slot --</span> <span m=''892000''>--
  into a list. So for example,</span> <span m=''896000''>imagine this is my hash table
  and this for example is slot i.</span> </p><p><span m=''907000''>I may have several
  things that are, so I''m going to put the key</span> <span m=''913000''>value --</span>
  <span m=''922000''>-- have several things that may have been inserted into this</span>
  <span m=''928000''>table that are elements of S. And what I''ll do is just link</span>
  <span m=''935000''>them together. OK, so nil pointer here.</span> </p><p><span m=''938000''>And
  this is the satellite data and these are the keys.</span> </p><p><span m=''943000''>So
  if they''re all linked together in slot i,</span> <span m=''946000''>then the hash
  function applied to 49 has got to be equal to the</span> <span m=''951000''>hash
  function of 86 is equal to the hash function of 52,</span> <span m=''955000''>which
  equals what?</span> </p><p><span m=''968000''>There''s only one thing I haven''t.</span>
  </p><p><span m=''970000''>i. Good.</span> </p><p><span m=''971000''>Even if you
  don''t understand it, your quizmanship should tell</span> <span m=''976000''>you.
  He didn''t mention i.</span> </p><p><span m=''978000''>That''s equal to i. So the
  point is when I hash 49,</span> <span m=''982000''>the hash of 49 produces me some
  index in the table,</span> <span m=''986000''>say i, and everything that hashes
  to that same location is</span> <span m=''991000''>linked together into a list OK.</span>
  </p><p><span m=''995000''>Every record. Any questions about what the</span> <span
  m=''999000''>mechanics of this. I hope that most of you have</span> <span m=''1004000''>seen
  this, seen hashing, basic hashing in 6.001,</span> <span m=''1009000''>right? They
  teach it in?</span> </p><p><span m=''1011000''>They used to teach it 6.001. Yeah.</span>
  </p><p><span m=''1015000''>OK. Some people are saying maybe.</span> </p><p><span
  m=''1018000''>They used to teach it. Good.</span> </p><p><span m=''1021000''>So
  let''s analyze this strategy. The analysis.</span> </p><p><span m=''1027000''>We''ll
  first do worst case.</span> </p><p><span m=''1038000''>So what happens in the worst
  case?</span> </p><p><span m=''1042000''>With hashing? Yeah, raise your hand so that
  I</span> <span m=''1047000''>could call on you. Yeah.</span> </p><p><span m=''1050000''>Yeah,
  all hash keys, well all, all the keys in S.</span> </p><p><span m=''1057000''>I
  happen to pick a set S where my hash function happens to map</span> <span m=''1066000''>them
  all to the same value. That would be bad.</span> </p><p><span m=''1074000''>So every
  key hashes to the same slot.</span> </p><p><span m=''1081000''>And so, therefore
  if that happens, then what I''ve</span> <span m=''1084000''>essentially built is
  a fancy linked list for keeping this</span> <span m=''1088000''>data structure.
  All this stuff with the tables,</span> <span m=''1091000''>the hashing, etc., irrelevant.</span>
  </p><p><span m=''1093000''>All that matters is that I have a long linked list.</span>
  </p><p><span m=''1097000''>And then how long does an access take?</span> </p><p><span
  m=''1100000''>How long does it take me to insert something or well,</span> <span
  m=''1103000''>more importantly, to search for something.</span> </p><p><span m=''1106000''>Find
  out whether something''s in there.</span> </p><p><span m=''1109000''>In the worst
  case. Yeah, it takes order n time.</span> </p><p><span m=''1115000''>Because they''re
  all just a link, we just have a linked</span> <span m=''1121000''>list. So access
  takes data n time if</span> <span m=''1126000''>as we assume the size of S is equal
  to n.</span> </p><p><span m=''1130000''>So from a worst case point of view, this
  doesn''t look so</span> <span m=''1137000''>attractive. And we will see data structures</span>
  <span m=''1142000''>that in worst case do very well for this problem.</span> </p><p><span
  m=''1145000''>But they don''t do as good as the average case of hashing.</span>
  </p><p><span m=''1149000''>So let''s analyze the average case.</span> </p><p><span
  m=''1158000''>In order to analyze the average case, I have to,</span> <span m=''1161000''>whenever
  you have averages, whenever you have probability,</span> <span m=''1165000''>you
  have to state your assumptions.</span> </p><p><span m=''1167000''>You have to say
  what is the assumption about the behavior of</span> <span m=''1171000''>the system.
  And it''s very hard to do that</span> <span m=''1174000''>because you don''t know
  necessarily what the hash</span> <span m=''1176000''>function is. Well, let''s imagine
  an ideal</span> <span m=''1179000''>hash function. What should an ideal hash</span>
  <span m=''1181000''>function do?</span> </p><p><span m=''1194000''>Yeah, map the
  keys essentially at random to a slot.</span> </p><p><span m=''1200000''>Should really
  distribute them randomly.</span> </p><p><span m=''1203000''>So we call this the
  assumption --</span> <span m=''1211000''>-- of simple uniform hashing.</span> </p><p><span
  m=''1224000''>And what it means is that each key k in S is equally likely --</span>
  <span m=''1241000''>-- to be hashed to any slot in T and we''re actually have to</span>
  <span m=''1250000''>make an independence assumption. Independent of where other</span>
  <span m=''1260000''>records, other keys are hashed.</span> </p><p><span m=''1278000''>So
  we''re going to make this assumption and includes n an</span> <span m=''1283000''>independence
  assumption. That if I have two keys the</span> <span m=''1287000''>odds that they''re
  hashed to the same place is therefore what?</span> </p><p><span m=''1294000''>What
  are the odds that two keys under this assumption are hashed</span> <span m=''1299000''>to
  the same slot, if I have, say,</span> <span m=''1302000''>m slots? One over m.</span>
  </p><p><span m=''1304000''>What are the odds that one key is hashed to slot 15?</span>
  </p><p><span m=''1308000''>One over m. Because they''re being</span> <span m=''1311000''>distributed,
  but the odds in particular two keys are hashed</span> <span m=''1316000''>to the
  same slot, one over m.</span> </p><p><span m=''1328000''>So let''s define. Is there
  a question?</span> </p><p><span m=''1334000''>No. OK.</span> </p><p><span m=''1336000''>The
  load factor of a hash table with n keys at m slots to be</span> <span m=''1347000''>alpha
  which is equal to n over m, which is also if you think</span> <span m=''1358000''>about
  it, just the average number of keys per slot.</span> </p><p><span m=''1378000''>So
  alpha is the average number of keys per, we call it the load</span> <span m=''1382000''>factor
  of the table. OK.</span> </p><p><span m=''1384000''>How many on average keys do
  I have?</span> </p><p><span m=''1387000''>So the expected, we''ll look first at</span>
  <span m=''1391000''>unsuccessful search time. So by unsuccessful search,</span>
  <span m=''1397000''>I mean I''m looking for something that''s actually not in</span>
  <span m=''1402000''>the table. It''s going to return nil.</span> </p><p><span m=''1406000''>I
  look for a key that''s not in the table.</span> </p><p><span m=''1412000''>It''s
  going to be what? It''s going to be order.</span> </p><p><span m=''1415000''>Well,
  I have to do a certain amount of work just to calculate</span> <span m=''1420000''>the
  hash function and so forth. It''s going to be order at least</span> <span m=''1426000''>one
  plus, then I have to search the list and on average how much</span> <span m=''1431000''>of
  the list do I have to search?</span> </p><p><span m=''1441000''>What''s the cost
  of searching that list?</span> </p><p><span m=''1444000''>On average. If I''m searching
  at random.</span> </p><p><span m=''1448000''>If I''m searching for a key that''s
  not in the table.</span> </p><p><span m=''1453000''>Whichever one it is, I got to
  search to the end of</span> <span m=''1458000''>the list, right? So what''s the
  average cost over</span> <span m=''1463000''>all the slots in the table? Alpha.</span>
  </p><p><span m=''1466000''>Right? Alpha.</span> </p><p><span m=''1467000''>That''s
  the average length of a list.</span> </p><p><span m=''1473000''>So this is essentially
  the cost of doing the hash and then</span> <span m=''1480000''>accessing the slot
  and that is just the cost of searching the</span> <span m=''1487000''>list.</span>
  </p><p><span m=''1494000''>So the expected unsuccessful search time is proportional</span>
  <span m=''1498000''>essentially to alpha and if alpha''s bigger than one,</span>
  <span m=''1502000''>it''s order alpha. If alpha''s less than one,</span> <span m=''1505000''>it''s
  constant.</span> </p><p><span m=''1513000''>So when is the expected search time
  --</span> <span m=''1526000''>-- equal to order one?</span> </p><p><span m=''1534000''>So
  when is this order one?</span> </p><p><span m=''1546000''>Simple questions, by the
  way.</span> </p><p><span m=''1548000''>I only ask simple questions. Some guys ask
  hard questions.</span> </p><p><span m=''1553000''>Yeah. Or in terms first we''ll
  get</span> <span m=''1555000''>there in two steps, OK.</span> </p><p><span m=''1557000''>In
  terms of alpha, it''s when?</span> </p><p><span m=''1561000''>When alpha is constant.
  If alpha in particular is.</span> </p><p><span m=''1566000''>Alpha doesn''t have
  to be constant.</span> </p><p><span m=''1570000''>It could be less than constant.
  It''s O of one,</span> <span m=''1575000''>right. OK, or equivalently,</span> <span
  m=''1578000''>which is what you said, if n is O of m.</span> </p><p><span m=''1582000''>OK,
  which is to say if the number of elements in the table</span> <span m=''1589000''>is
  order, is upper bounded by a constant times n.</span> </p><p><span m=''1596000''>Then
  the search cost is constant.</span> </p><p><span m=''1598000''>So a lot of people
  will tell you oh, a hash table runs in</span> <span m=''1602000''>constant search
  time. OK, that''s actually wrong.</span> </p><p><span m=''1605000''>It depends upon
  the load factor of the hash table.</span> </p><p><span m=''1608000''>And people
  have made programming errors based on that</span> <span m=''1612000''>misunderstanding
  of hash tables. Because they have a hash table</span> <span m=''1616000''>that''s
  too small for the number of elements they''re putting in</span> <span m=''1620000''>there.
  Doesn''t help.</span> </p><p><span m=''1623000''>The number may in fact will grow
  with the,</span> <span m=''1627000''>since this is one plus n over m, it actually
  grows with n.</span> </p><p><span m=''1634000''>So unless you make sure that m keeps
  up with n,</span> <span m=''1638000''>this doesn''t stay constant. Now it turns
  out for a</span> <span m=''1644000''>successful search, it''s also one plus alpha.</span>
  </p><p><span m=''1650000''>And for that you need to do a little bit more mathematics</span>
  <span m=''1654000''>because you now have to condition on searching for the</span>
  <span m=''1658000''>items in the table. But it turns out it''s also one</span> <span
  m=''1661000''>plus alpha and that you can read about in the book.</span> </p><p><span
  m=''1665000''>And also, there''s a more rigorous proof of this.</span> </p><p><span
  m=''1669000''>I sort of have glossed over the expectation stuff here,</span> <span
  m=''1673000''>doing sort of a more intuitive proof.</span> </p><p><span m=''1675000''>So
  both of those things you should look for in the book.</span> </p><p><span m=''1681000''>So
  this is one reason why hashing is such a popular</span> <span m=''1685000''>method,
  is it basically lets you represent a dynamic set with</span> <span m=''1690000''>order
  one cost per operation, constant cost per operation,</span> <span m=''1694000''>inserting,
  deleting and so forth, as long as the table that</span> <span m=''1699000''>you''re
  keeping is not much smaller than the number of items</span> <span m=''1704000''>that
  you''re putting in there. And then all the operations end</span> <span m=''1709000''>up
  being constant time. But it depends upon,</span> <span m=''1713000''>strongly upon
  this assumption of simple uniform hashing.</span> </p><p><span m=''1717000''>And
  so no matter what hash function you pick,</span> <span m=''1721000''>I can always
  find a set of elements that are going to hash,</span> <span m=''1725000''>that that
  hash function is going to hash badly.</span> </p><p><span m=''1729000''>I just could
  generate a whole bunch of them and look to see</span> <span m=''1733000''>where
  the hash function takes them and in the end pick a whole</span> <span m=''1738000''>bunch
  that hash to the same place.</span> </p><p><span m=''1742000''>We''re actually going
  to see a way of countering that,</span> <span m=''1745000''>but in practice people
  understand that most programs</span> <span m=''1749000''>that need to use things
  aren''t really reverse engineering the</span> <span m=''1754000''>hash function.
  And so, there''s some very</span> <span m=''1757000''>simple hash functions that
  seem to work fairly well in practice.</span> </p><p><span m=''1761000''>So in choosing
  a hash function --</span> <span m=''1772000''>-- we would like it to distribute</span>
  <span m=''1780000''>-- keys uniformly into slots and we also would like that</span>
  <span m=''1791000''>regularity in the key distributions --</span> <span m=''1806000''>--
  should not affect uniformity.</span> </p><p><span m=''1808000''>For example, a regularity
  that you often see</span> <span m=''1812000''>is that all the keys that are being
  inserted are even numbers.</span> </p><p><span m=''1817000''>Somebody happens to
  have that property of his data,</span> <span m=''1821000''>that they''re only inserting
  even numbers.</span> </p><p><span m=''1824000''>In fact, on many machines, since
  they use byte pointers,</span> <span m=''1829000''>if they''re sorting things that
  are for example,</span> <span m=''1833000''>indexes to arrays or something like
  that, in fact,</span> <span m=''1837000''>they''re numbers that are typically divisible
  by four.</span> </p><p><span m=''1843000''>Or by eight. So you don''t want regularity
  in</span> <span m=''1845000''>the key distribution to affect the fact that you''re</span>
  <span m=''1849000''>distributing slots. So probably the most popular</span> <span
  m=''1852000''>method that''s used just for a quick hash function is what''s</span>
  <span m=''1856000''>called the division method.</span> </p><p><span m=''1867000''>And
  the idea here is that you simply let h of k for a key</span> <span m=''1871000''>equal
  k modulo m, where m is the number of slots</span> <span m=''1875000''>in your table.</span>
  </p><p><span m=''1884000''>And this works reasonably well in practice, but you want
  to be</span> <span m=''1888000''>careful about your choice of modulus.</span> </p><p><span
  m=''1891000''>In other words, it turns out it doesn''t work</span> <span m=''1893000''>well
  for every possible size of table you might want to pick.</span> </p><p><span m=''1896000''>Fortunately
  when you''re building hash tables,</span> <span m=''1898000''>you don''t usually
  care about the specific size of the table.</span> </p><p><span m=''1902000''>If
  you pick it around some size, that''s probably fine</span> <span m=''1905000''>because
  it''s not going to affect their performance.</span> </p><p><span m=''1907000''>So
  there''s no need to pick a specific value.</span> </p><p><span m=''1910000''>In
  particular, you don''t want to pick --</span> <span m=''1920000''>-- m with a small
  divisor --</span> <span m=''1931000''>-- and let me illustrate why that''s a bad
  idea for this</span> <span m=''1934000''>particular hash function.</span> </p><p><span
  m=''1947000''>I should have said small divisor d.</span> </p><p><span m=''1955000''>So
  for example --</span> <span m=''1960000''>-- if D is two, in other words m is an
  even</span> <span m=''1965000''>number, and it turns out that we have the situation
  I just</span> <span m=''1972000''>mentioned, all keys are even, what happens to
  my usage of the</span> <span m=''1980000''>hash table? So I have an even slot,</span>
  <span m=''1984000''>even number of slots, and all the keys that the user</span>
  <span m=''1989000''>of the hash table chooses to pick happen to be even numbers,</span>
  <span m=''1994000''>what''s going to happen in terms of my use of the hash table?</span>
  </p><p><span m=''1999000''>Well, in the worst case, they are always all going to</span>
  <span m=''2004000''>point in the same slot no matter what hash function I pick.</span>
  </p><p><span m=''2010000''>But here, let''s say that, in fact, my hash function
  does</span> <span m=''2015000''>do a pretty good job of distributing,</span> <span
  m=''2019000''>but I have this property. What''s a property that''s going</span>
  <span m=''2025000''>to have no matter what set of keys I pick that satisfies this</span>
  <span m=''2031000''>property? What''s going to happen to the</span> <span m=''2035000''>hash
  table? So, I have even number,</span> <span m=''2038000''>mod an even number. What
  does that say about the</span> <span m=''2044000''>hash function? It''s even, right?</span>
  </p><p><span m=''2048000''>I have an even number mod. It''s even.</span> </p><p><span
  m=''2051000''>So, what''s going to happen to my use of the table?</span> </p><p><span
  m=''2056000''>Yeah, you''re never going to hash anything to an odd-numbered</span>
  <span m=''2062000''>slot. You wasted half your slots.</span> </p><p><span m=''2066000''>It
  doesn''t matter what the key distribution is.</span> </p><p><span m=''2072000''>OK,
  as long as they''re all even, OK, that means the odds</span> <span m=''2078000''>slots
  are never used. OK, an extreme example,</span> <span m=''2083000''>here''s another
  example, imagine that m is equal to two</span> <span m=''2089000''>to the r. In
  other words,</span> <span m=''2092000''>all its factors are small divisors, OK?</span>
  </p><p><span m=''2098000''>In that case, if I think about taking k mod</span> <span
  m=''2106000''>n, OK, the hash doesn''t even depend on all the bits of k,</span>
  <span m=''2118000''>OK? So, for example,</span> <span m=''2122000''>suppose I had
  one..., and r equals six,</span> <span m=''2131000''>OK, so m is two to the sixth.
  So, I take this binary number,</span> <span m=''2143000''>mod two to the sixth,
  what''s the hash value?</span> </p><p><span m=''2150000''>If I take something mod
  a power of two, what does it do?</span> </p><p><span m=''2159000''>So, I hash this
  function. This is k, OK,</span> <span m=''2166000''>in binary. And I take it mod
  two to the</span> <span m=''2172000''>sixth. Well, if I took it mod two,</span>
  <span m=''2177000''>what''s the answer? What''s this number mod two?</span> </p><p><span
  m=''2184000''>Zero, right. OK, what''s this number mod</span> <span m=''2189000''>four?
  One zero.</span> </p><p><span m=''2192000''>What is it mod two to the sixth?</span>
  </p><p><span m=''2195000''>Yeah, it''s just these last six bits.</span> </p><p><span
  m=''2199000''>This is H of k. OK, when you take something mod</span> <span m=''2203000''>a
  power of two, all you''re doing is taking its</span> <span m=''2208000''>low order
  bits. OK, mod two to the r,</span> <span m=''2211000''>you are taking its r low
  order bits.</span> </p><p><span m=''2214000''>So, the hash function doesn''t even
  depend on what''s up here.</span> </p><p><span m=''2222000''>So, that''s a pretty
  bad situation because generally you</span> <span m=''2225000''>would like a very
  common regularity that you''ll see in</span> <span m=''2229000''>data is that all
  the low order bits are the same,</span> <span m=''2232000''>and all the high order
  bits differ, or vice versa.</span> </p><p><span m=''2236000''>So, this particular
  is not a very good one.</span> </p><p><span m=''2240000''>So, good heuristics for
  this is to pick m to be a prime,</span> <span m=''2245000''>not too close to a power
  of two or ten because those are the two</span> <span m=''2251000''>common bases
  that you see regularity in the world.</span> </p><p><span m=''2256000''>A prime
  is sometimes inconvenient,</span> <span m=''2259000''>however. But generally,</span>
  <span m=''2261000''>it''s fairly easy to find primes.</span> </p><p><span m=''2264000''>And
  there''s a lot of nice theorems about primes.</span> </p><p><span m=''2269000''>So,
  generally what you do, if you''re just coding up</span> <span m=''2274000''>something
  and you know what it is, you can pick a prime out of</span> <span m=''2280000''>a
  textbook or look it up on the web or write a little program,</span> <span m=''2286000''>or
  whatever, and pick a prime.</span> </p><p><span m=''2291000''>Not too close to a
  power of two or ten, and it will probably</span> <span m=''2295000''>work pretty
  well. It will probably work pretty</span> <span m=''2298000''>well. So, this is
  a very popular</span> <span m=''2300000''>method, the division method. OK, but the
  next method we are</span> <span m=''2304000''>going to see is actually usually superior.</span>
  </p><p><span m=''2307000''>The reason people do this is because they can write in-line</span>
  <span m=''2312000''>in their code. OK, but it''s not usually the</span> <span m=''2316000''>best
  method. And the reason is because</span> <span m=''2319000''>division, one of the
  reasons is division tends to take a lot of</span> <span m=''2324000''>cycles to
  compute on most computers compared with</span> <span m=''2328000''>multiplication
  or addition. OK, in fact,</span> <span m=''2331000''>it''s usually done with taking
  several multiplications.</span> </p><p><span m=''2335000''>So, the next method is
  actually generally better,</span> <span m=''2339000''>but none of the hash function
  methods that we are talking</span> <span m=''2343000''>about today are, in some
  sense,</span> <span m=''2346000''>provably good hash functions. OK, so for the multiplication</span>
  <span m=''2352000''>method, the nice thing about it is just essentially requires</span>
  <span m=''2358000''>multiplication to do. And, for that is,</span> <span m=''2362000''>also,
  we are going to assume that the number of slots is a</span> <span m=''2368000''>power
  of two which is also often very convenient.</span> </p><p><span m=''2372000''>OK,
  and for this, we''re going to assume that the</span> <span m=''2377000''>computer
  has w bit words. So, it would be convenient on a</span> <span m=''2384000''>computer
  with 32 bits, or 64 bits, for example.</span> </p><p><span m=''2390000''>OK, this
  would be very convenient.</span> </p><p><span m=''2394000''>So, the hash function
  is the following.</span> </p><p><span m=''2399000''>h of k is equal to A times k
  mod, two to the w,</span> <span m=''2404000''>right shifted by w minus r. OK, so
  the key part of this is</span> <span m=''2412000''>A, which has chosen to be an
  odd integer in the range between two</span> <span m=''2420000''>to the w minus one
  and two to the w.</span> </p><p><span m=''2424000''>OK, so it''s an odd integer
  that the full width of the computer</span> <span m=''2431000''>word. OK, and what
  you do is multiply</span> <span m=''2436000''>it by whatever your key is, by this
  funny integer.</span> </p><p><span m=''2442000''>And, then take it mod two to the
  w.</span> </p><p><span m=''2447000''>And then, you take the result and right shift
  it by this fixed</span> <span m=''2454000''>amount, w minus r. So, this is a bit
  wise right</span> <span m=''2460000''>shift. OK, so let''s look at what this</span>
  <span m=''2466000''>does. But first, let me just give you</span> <span m=''2472000''>a
  couple of tips on how you pick, or what you don''t pick for</span> <span m=''2481000''>A.
  So, you don''t pick A too close</span> <span m=''2487000''>to a power of two. And,
  it''s generally a pretty</span> <span m=''2494000''>fast method because multiplication
  mod two to the w</span> <span m=''2502000''>is faster than division. And the other
  thing is that a</span> <span m=''2509000''>right shift is fast, especially because
  this is a</span> <span m=''2512000''>known shift. OK, you know it before you are</span>
  <span m=''2515000''>computing the hash function. Both w and r are known in</span>
  <span m=''2519000''>advance. So, the compiler can often do</span> <span m=''2522000''>tricks
  there to make it go even faster.</span> </p><p><span m=''2526000''>So, let''s do
  an example to understand how this hash</span> <span m=''2531000''>function works.
  So, we will have,</span> <span m=''2534000''>in this case, a number of slots will
  be</span> <span m=''2538000''>eight, which is two to the three.</span> </p><p><span
  m=''2542000''>And, we''ll have a bizarre word size of seven bits.</span> </p><p><span
  m=''2546000''>Anybody know any seven bit computers out there?</span> </p><p><span
  m=''2553000''>OK, well, here''s one. So, A is our fixed value that''s</span> <span
  m=''2559000''>used for hashing all our keys. And, in this case,</span> <span m=''2565000''>let''s
  say it''s 1011001. So, that''s A.</span> </p><p><span m=''2570000''>And, I take
  in some value for k that I''m going to multiply.</span> </p><p><span m=''2577000''>So,
  k is going to be 1101011. So, that''s my k.</span> </p><p><span m=''2584000''>And,
  I multiply them. What I multiply two,</span> <span m=''2587000''>each of these is
  the full word width.</span> </p><p><span m=''2590000''>You can view it as the full
  word width of the machine,</span> <span m=''2594000''>in this case, seven bits.</span>
  </p><p><span m=''2596000''>So, in general, this would be like a 32 bit</span> <span
  m=''2600000''>number, and my key, I''d be multiplying two 32 bit</span> <span m=''2604000''>numbers,
  for example. OK, and so, when I multiply</span> <span m=''2608000''>that out, I
  get a 2w bit answer. So, when you multiply two w bit</span> <span m=''2613000''>numbers,
  you get a 2w bit answer.</span> </p><p><span m=''2618000''>In this case, it happens
  to be that number,</span> <span m=''2624000''>OK? So, that''s the product part,</span>
  <span m=''2629000''>OK? And then we take it mod two to</span> <span m=''2634000''>the
  w. Well, what mod two to the w</span> <span m=''2639000''>says is that I''m just
  taking, ignoring the high order bits of</span> <span m=''2649000''>this product.
  So, all of these are ignored,</span> <span m=''2656000''>because, remember that
  if I take something,</span> <span m=''2662000''>mod, a power of two, that''s just
  the low order bits.</span> </p><p><span m=''2670000''>So, I just get these low order
  bits as being the mod.</span> </p><p><span m=''2673000''>And then, the right shift
  operation, and that''s good also,</span> <span m=''2678000''>by the way, because
  a lot of machines, when I multiply two 32</span> <span m=''2682000''>bit numbers,
  they''ll have an instruction that gives you just</span> <span m=''2686000''>the
  32 lower bits. And, it''s usually an</span> <span m=''2689000''>instruction that''s
  faster than the instruction that gives you</span> <span m=''2694000''>the full 64
  bit answer. OK, so, that''s very convenient.</span> </p><p><span m=''2698000''>And,
  the second thing is, then, that I want just the,</span> <span m=''2701000''>in this
  case, three bits that are the high</span> <span m=''2704000''>order bits of this
  word. So, this ends up being my H of</span> <span m=''2711000''>k. And these end
  up getting</span> <span m=''2713000''>removed by right shifting this word over.</span>
  </p><p><span m=''2718000''>So, you just right shift that in, zeros come in,</span>
  <span m=''2723000''>in a high order bit, and you end up getting that</span> <span
  m=''2728000''>value of H of k. OK, so to understand what''s</span> <span m=''2732000''>going
  on here, why this is a pretty good</span> <span m=''2736000''>method, or what''s
  happening with it, you can imagine that one way</span> <span m=''2743000''>to think
  about it is to think of A as being a binary fraction.</span> </p><p><span m=''2752000''>So,
  imagine that the decimal point is here,</span> <span m=''2755000''>sorry, the binary
  point, OK, the radix point is here.</span> </p><p><span m=''2760000''>Then when
  I multiply things, I''m just taking,</span> <span m=''2763000''>the binary point
  ends up being there.</span> </p><p><span m=''2766000''>OK, so if you just imagine
  that conceptually,</span> <span m=''2769000''>we don''t have to actually put this
  into the hardware because</span> <span m=''2774000''>we just do what the hardware
  does.</span> </p><p><span m=''2776000''>But, I can imagine that it''s there, and
  that it''s here.</span> </p><p><span m=''2780000''>And so, what I''m really taking
  is the fractional part of this</span> <span m=''2785000''>product if I treat A as
  a fraction of a number.</span> </p><p><span m=''2789000''>So, we can certainly look
  at that as sort of a modular wheel.</span> </p><p><span m=''2795000''>So, here I
  have a wheel where this is going to be,</span> <span m=''2799000''>that I''m going
  to divide into eight parts, OK,</span> <span m=''2803000''>where this point is zero.
  And then, I go around,</span> <span m=''2808000''>and this point is then one. And,
  I go around,</span> <span m=''2812000''>and this point is two, and so forth,</span>
  <span m=''2815000''>so that all the integers, if I wrap it around this unit</span>
  <span m=''2821000''>wheel, all the integers lined up at the zero point here,</span>
  <span m=''2826000''>OK? And then, we can divide this</span> <span m=''2830000''>into
  the fractional pieces. So, that''s essentially the zero</span> <span m=''2834000''>point.
  This is the one eighth,</span> <span m=''2837000''>because we are dividing into
  eight, two, three,</span> <span m=''2840000''>four, five, six, seven.</span> </p><p><span
  m=''2843000''>So, if I have one times A, in this case,</span> <span m=''2848000''>I''m
  basically saying, well, one times A,</span> <span m=''2853000''>if I multiply, is
  basically going around to</span> <span m=''2859000''>about there, five and a half
  I think, right,</span> <span m=''2865000''>because one times A is about five and
  a half,</span> <span m=''2871000''>OK, or five halves of 5.5 eighths, essentially.</span>
  </p><p><span m=''2879000''>So, it takes me about to there. That''s A.</span> </p><p><span
  m=''2884000''>And, if I do 2^A, that continues around,</span> <span m=''2889000''>and
  takes me up to about, where?</span> </p><p><span m=''2892000''>About, a little past
  three, about to there.</span> </p><p><span m=''2898000''>So, that''s 2^A. OK, and
  3^A takes me,</span> <span m=''2902000''>then, around to somewhere like about there.</span>
  </p><p><span m=''2908000''>So, each time I add another A, it''s taking me another
  A''s</span> <span m=''2915000''>distance around. And, the idea is that if A is,</span>
  <span m=''2921000''>for example, odd, and it''s not too close to</span> <span m=''2924000''>a
  power of two, then what''s happening is sort</span> <span m=''2928000''>of throwing
  it into another slot on a different thing.</span> </p><p><span m=''2932000''>So,
  if I now go around, if I have k being very big,</span> <span m=''2937000''>then
  k times A is going around k times.</span> </p><p><span m=''2941000''>Where does
  it end up? It''s like spinning a wheel of</span> <span m=''2944000''>fortune or
  something. OK, it ends somewhere.</span> </p><p><span m=''2946000''>OK, and so that''s
  basically the notion.</span> </p><p><span m=''2949000''>That''s basically the notion,
  that it''s going to end up in</span> <span m=''2952000''>some place. So, you''re
  basically looking</span> <span m=''2955000''>at, where does ka end up? Well, it
  sort of whirls around,</span> <span m=''2958000''>and ends up at some point. OK,
  and so that''s why that</span> <span m=''2962000''>tends to be a fairly good one.
  But, these are only heuristic</span> <span m=''2966000''>methods for hashing, because
  for any hash function,</span> <span m=''2969000''>you can always find a set of keys
  that''s going to make it</span> <span m=''2972000''>operate badly. So, the question
  is,</span> <span m=''2978000''>well, what do you use in practice?</span> </p><p><span
  m=''2984000''>OK, the second topic that I want to tie it,</span> <span m=''2992000''>so,
  we talked about resolving collisions by chaining.</span> </p><p><span m=''3003000''>OK,
  there''s another way of resolving collisions,</span> <span m=''3011000''>which is
  often useful, which is resolving collisions</span> <span m=''3019000''>by what''s
  called open addressing.</span> </p><p><span m=''3025000''>OK, and the idea is, in
  this method,</span> <span m=''3031000''>is we have no storage for links.</span>
  </p><p><span m=''3038000''>So, when I result by chaining, I''d need an extra linked
  field</span> <span m=''3043000''>in each record in order to be able to do that.</span>
  </p><p><span m=''3047000''>Now, that''s not necessarily a big overhead,</span> <span
  m=''3051000''>but for some applications, I don''t want to have to touch</span> <span
  m=''3057000''>those records at all. OK, and for those,</span> <span m=''3060000''>open
  addressing is a useful way to resolve collisions.</span> </p><p><span m=''3067000''>So,
  the idea is, with open addressing,</span> <span m=''3070000''>is if I hash to a
  given slot, and the slot is full,</span> <span m=''3075000''>OK, what I do is I
  just hash again with a different hash</span> <span m=''3081000''>function, with
  my second hash function.</span> </p><p><span m=''3085000''>I check that slot. OK,
  if that slot is full,</span> <span m=''3089000''>OK, then I hash again. And, I keep
  this probe</span> <span m=''3094000''>sequence, which hopefully is a permutation
  so that I''m not</span> <span m=''3099000''>going back and checking things that
  I''ve already checked until</span> <span m=''3103000''>I find a place to put it.
  And, if I got a good probe</span> <span m=''3107000''>sequence that I will hopefully,
  then, find a place to put it</span> <span m=''3112000''>fairly quickly. OK, and
  then to search,</span> <span m=''3115000''>I just follow the same probe sequence.</span>
  </p><p><span m=''3119000''>So, the idea, here, is we probe the table</span> <span
  m=''3125000''>systematically until an empty slot is found,</span> <span m=''3132000''>OK?
  And so, we can extend that by</span> <span m=''3137000''>looking as if the sequence
  of hash functions were,</span> <span m=''3145000''>in fact, a hash function that
  took two arguments:</span> <span m=''3152000''>a key and a probe step. In other
  words,</span> <span m=''3160000''>is it the zero of one our first one?</span> </p><p><span
  m=''3164000''>It''s the second one, etc.</span> </p><p><span m=''3168000''>So, it
  takes two arguments. So, H is then going to map our</span> <span m=''3175000''>universe
  of keys cross, our probe number into a slot.</span> </p><p><span m=''3184000''>So,
  this is the universe of keys.</span> </p><p><span m=''3190000''>This is the probe
  number. And, this is going to be the</span> <span m=''3200000''>slot. Now, as I
  mentioned,</span> <span m=''3205000''>the probe sequence should be permutation.</span>
  </p><p><span m=''3214000''>In other words, it should just be the numbers</span>
  <span m=''3218000''>from zero to n minus one in some fairly random order.</span>
  </p><p><span m=''3224000''>OK, it should just be rearranged.</span> </p><p><span
  m=''3228000''>And the other thing about open addressing is that you don''t</span>
  <span m=''3234000''>have to worry about n chaining is that the table may actually</span>
  <span m=''3241000''>fill up. So, you have to have that the</span> <span m=''3245000''>number
  of elements in the table is less than or equal to the</span> <span m=''3250000''>table
  size, the number of slots because the table may fill up.</span> </p><p><span m=''3256000''>And,
  if it''s full, you''re going to probe</span> <span m=''3259000''>everywhere. You
  are never going to get a</span> <span m=''3263000''>place to put it. And, the final
  thing is that in</span> <span m=''3267000''>this type of scheme, deletion is difficult.</span>
  </p><p><span m=''3272000''>It''s not impossible. There are schemes for doing</span>
  <span m=''3274000''>deletion. But, it''s basically hard</span> <span m=''3276000''>because
  the danger is that you remove a key out of the table,</span> <span m=''3280000''>and
  now, somebody who''s doing a probe sequence who would have</span> <span m=''3284000''>hit
  that key and gone to find his element now finds that it''s</span> <span m=''3287000''>an
  empty slot. And he says,</span> <span m=''3289000''>oh, the key I am looking for
  probably isn''t there.</span> </p><p><span m=''3292000''>OK, so you have that issue
  to deal with.</span> </p><p><span m=''3294000''>So, you can delete things but keep
  them marked,</span> <span m=''3297000''>and there''s all kinds of schemes that people
  have for</span> <span m=''3300000''>doing deletion. But it''s difficult.</span>
  </p><p><span m=''3304000''>It''s messy compared to chaining, where you can just</span>
  <span m=''3307000''>remove the element out of the chain.</span> </p><p><span m=''3309000''>So,
  let''s do an example --</span> <span m=''3325000''>-- just so that we make sure
  we''re on the same page.</span> </p><p><span m=''3337000''>So, we''ll insert a key.
  k is 496.</span> </p><p><span m=''3345000''>OK, so here''s my table. And, I''ve
  got some values in</span> <span m=''3357000''>it, 586, 133, 204, 481, etc.</span>
  </p><p><span m=''3366000''>So, the table looks like that; the other places are empty.</span>
  </p><p><span m=''3373000''>So, on my zero step, I probe H of 496,</span> <span m=''3378000''>zero.
  OK, and let''s say that takes me</span> <span m=''3382000''>to the slot where there''s
  204. And so, I say,</span> <span m=''3388000''>oh, there''s something there. I have
  to probe again.</span> </p><p><span m=''3396000''>So then, I probe H of 496, one.</span>
  </p><p><span m=''3401000''>Maybe that maps me there, and I discover,</span> <span
  m=''3407000''>oh, there''s something there. So, now, I probe H of 496,</span> <span
  m=''3415000''>two. Maybe that takes me to there.</span> </p><p><span m=''3422000''>It''s
  empty. So, if I''m doing a search,</span> <span m=''3424000''>I report nil. If I''m
  doing in the insert,</span> <span m=''3427000''>I put it there. And then, if I''m
  looking for</span> <span m=''3431000''>that value, if I put it there, then when
  I''m looking,</span> <span m=''3435000''>I go through exactly the same sequence.</span>
  </p><p><span m=''3438000''>I''ll find these things are busy, and then,</span> <span
  m=''3441000''>eventually, I''ll come up and discover the value.</span> </p><p><span
  m=''3446000''>OK, and there are various heuristics that people use,</span> <span
  m=''3449000''>as well, like keeping track of the longest probe sequence</span> <span
  m=''3454000''>because there''s no point in probing beyond the largest</span> <span
  m=''3457000''>number of probes that need to be done globally to do an</span> <span
  m=''3461000''>insertion. OK, so if it took me 5,</span> <span m=''3464000''>5 is
  the maximum number of probes I ever did for an</span> <span m=''3468000''>insertion.
  A search never has to look more</span> <span m=''3471000''>than five, OK, and so
  sometimes hash tables</span> <span m=''3474000''>will keep that auxiliary value
  so that it can quit rather than</span> <span m=''3478000''>continuing to probe until
  it doesn''t find something.</span> </p><p><span m=''3484000''>OK, so, search is
  the same probe sequence.</span> </p><p><span m=''3493000''>And, if it''s successful,
  it finds the record.</span> </p><p><span m=''3503000''>And, if it''s unsuccessful,
  you find a nil.</span> </p><p><span m=''3514000''>OK, so it''s pretty straightforward.</span>
  </p><p><span m=''3517000''>So, once again, as with just hash functions to</span>
  <span m=''3522000''>begin with, there are a lot of ideas about how you should form</span>
  <span m=''3529000''>a probe sequence, ways of doing this effectively.</span> </p><p><span
  m=''3546000''>OK, so the simplest one is called linear probing,</span> <span m=''3554000''>and
  what you do there is you have H of k comma i.</span> </p><p><span m=''3562000''>You
  just make that be some H prime of k, zero plus i mod m.</span> </p><p><span m=''3573000''>Sorry,
  no prime there. OK, so what happens is,</span> <span m=''3576000''>so, the idea
  here is that all you are doing on the I''th probe</span> <span m=''3581000''>is,
  on the zero''th probe, you look at H of k zero.</span> </p><p><span m=''3584000''>On
  probe one, you just look at the slot after</span> <span m=''3588000''>that. Probe
  two, you look at the slot</span> <span m=''3590000''>after that. So, you''re just
  simply,</span> <span m=''3593000''>rather than sort of jumping around like this,</span>
  <span m=''3596000''>you probe there and then just find the next one that will fit</span>
  <span m=''3601542''>in. OK, so you just scan down mod</span> <span m=''3604785''>m.
  So, if you hit the bottom,</span> <span m=''3606509''>you go to the top. OK, so
  the I''th one,</span> <span m=''3608848''>so that''s fairly easy to do because you
  don''t have to</span> <span m=''3612050''>recomputed a full hash function each time.</span>
  </p><p><span m=''3614574''>All you have to do is add one each time you go because
  the</span> <span m=''3618083''>difference between this and the previous one is just
  one.</span> </p><p><span m=''3621531''>OK, so you just go down. Now, the problem
  with that is</span> <span m=''3624794''>that you get a phenomenon of clustering.</span>
  </p><p><span m=''3627195''>If you get a few things in a given area, then suddenly</span>
  <span m=''3630458''>everything, everybody has to keep searching to the end of</span>
  <span m=''3633906''>those things. OK, so that turns out not to be</span> <span m=''3638277''>one
  of the better schemes, although it''s not bad if you</span> <span m=''3642246''>just
  need to do something quick and dirty.</span> </p><p><span m=''3645258''>So, it suffers
  from primary clustering, where regions of the</span> <span m=''3649594''>hash table
  get very full. And then, anything that hashes</span> <span m=''3653635''>into that
  region has to look through all the stuff that''s</span> <span m=''3657750''>there.
  OK, so: long runs of filled</span> <span m=''3662030''>slots. OK, there''s also
  things like</span> <span m=''3665846''>quadratic clustering, where you basically
  make this</span> <span m=''3671459''>be, instead of adding one each time, you add
  i each time.</span> </p><p><span m=''3677744''>OK, but probably the most effective
  popular scheme is</span> <span m=''3683581''>what''s called double hashing. And,
  you can do statistical</span> <span m=''3689867''>studies. People have done statistical</span>
  <span m=''3695715''>studies to show that this is a good scheme, OK,</span> <span
  m=''3701819''>where you let H of k, i, let me do it below here</span> <span m=''3708056''>because
  I have for them. So, H of k, i is equal to an</span> <span m=''3714957''>H_1 of
  k plus i times H_2 of k. So, you have two hash functions</span> <span m=''3723467''>on
  m. You have two hash functions,</span> <span m=''3727157''>H_1 of k and H_2 of k.
  OK, so you compute the two hash</span> <span m=''3733085''>functions, and what you
  do is you start by just using H_1 of k</span> <span m=''3739907''>for the zero probe,
  because here,</span> <span m=''3743486''>i, then, will be zero. OK.</span> </p><p><span
  m=''3746282''>Then, for the probe number one, OK, you just add H_2 of k.</span>
  </p><p><span m=''3754000''>For probe number two, you just add that hash function</span>
  <span m=''3757466''>amount again. You just keep adding H_2 of k</span> <span m=''3760266''>for
  each successive probe you make.</span> </p><p><span m=''3762533''>So, it''s fairly
  easy; you compute two hash functions</span> <span m=''3765933''>up front, OK, or
  you can delay the second</span> <span m=''3768599''>one, in case. But basically,</span>
  <span m=''3770400''>you compute two up front, and then you just keep adding</span>
  <span m=''3774000''>the second one in. You start at the location of</span> <span
  m=''3777066''>the first one, and keep adding the second one,</span> <span m=''3780066''>mod
  m, to determine your probe sequences.</span> </p><p><span m=''3784000''>So, this
  is an excellent method.</span> </p><p><span m=''3787757''>OK, it does a fine job,
  and you usually pick m to be a</span> <span m=''3794181''>power of two here, OK,
  so that you''re using,</span> <span m=''3799393''>usually people use this with the
  multiplication method,</span> <span m=''3805939''>for example, so that m is a power
  of two,</span> <span m=''3810787''>and H_2 of k you force to be odd.</span> </p><p><span
  m=''3816000''>OK, so we don''t use and even value there, because otherwise</span>
  <span m=''3820578''>for any particular key, you''d be skipping over.</span> </p><p><span
  m=''3824210''>Once again, you would have the problem that everything could be</span>
  <span m=''3829105''>even, or everything could be odd as you''re going through.</span>
  </p><p><span m=''3833526''>But, if you make H_2 of k odd, and m is a power of two,</span>
  <span m=''3837788''>you are guaranteed to hit every slot.</span> </p><p><span m=''3840631''>OK,
  so let''s analyze this scheme.</span> </p><p><span m=''3843157''>This turns out
  to be a pretty interesting scheme to analyze.</span> </p><p><span m=''3849000''>It''s
  got some nice math in it. So, once again,</span> <span m=''3854080''>in the worst
  case, hashing is lousy.</span> </p><p><span m=''3858032''>So, we''re going to analyze
  average case.</span> </p><p><span m=''3875000''>OK, and for this, we need a little
  bit stronger</span> <span m=''3885615''>assumption than for chaining. And, we call
  it the assumption</span> <span m=''3899230''>of uniform hashing, which says that
  each key is</span> <span m=''3909846''>equally likely, OK, to have any one of the
  m</span> <span m=''3919769''>factorial permutations as its probe sequence,</span>
  <span m=''3932000''>independent of other keys.</span> </p><p><span m=''3945000''>And,
  the theorem we''re going to prove is that the expected</span> <span m=''3955291''>number
  of probes is, at most, one over one minus</span> <span m=''3963777''>alpha if alpha
  is less than one, OK,</span> <span m=''3971000''>that is, if the number of keys
  in the table is less than number</span> <span m=''3977000''>of slots. OK, so we''re
  going to show that</span> <span m=''3980870''>the number of probes is one over one
  minus alpha.</span> </p><p><span m=''3994000''>So, alpha is the load factor, and
  of course,</span> <span m=''3998700''>for open addressing, we want the load factor
  to be</span> <span m=''4004057''>less than one because if we have more keys than
  slots,</span> <span m=''4009852''>open addressing simply doesn''t work, OK, because
  you''ve got to</span> <span m=''4016520''>find a place for every key in the table.</span>
  </p><p><span m=''4020784''>So, the proof, we''ll look at an unsuccessful</span>
  <span m=''4025485''>search, OK? So, the first thing is that one</span> <span m=''4032908''>probe
  is always necessary. OK, so if I have n over m,</span> <span m=''4041141''>sorry,
  if I have n items stored in m slots, what''s the</span> <span m=''4049533''>probability
  that when I do that probe I get a collision with</span> <span m=''4058875''>something
  that''s already in the table?</span> </p><p><span m=''4066000''>What''s the probability
  that I get a collision?</span> </p><p><span m=''4071526''>Yeah? Yeah, n over m,</span>
  <span m=''4073982''>right? So, with probability,</span> <span m=''4077298''>n over
  m, we have a collision because my table has got n</span> <span m=''4084052''>things
  in there. I''m hashing,</span> <span m=''4088487''>at random, to one of them. OK,
  so, what are the odds I hit</span> <span m=''4095551''>something, n over m? And
  then, a second probe is</span> <span m=''4101376''>necessary. OK, so then,</span>
  <span m=''4104102''>I do a second probe. And, with what probability on</span> <span
  m=''4110175''>the second probe do I get a collision?</span> </p><p><span m=''4116000''>So,
  we''re going to make the assumption of uniform hashing.</span> </p><p><span m=''4120158''>Each
  key is equally likely to have any one of the m factorial</span> <span m=''4124536''>permutations
  as its probe sequence.</span> </p><p><span m=''4127017''>So, what is the probability
  that on the second probe,</span> <span m=''4130810''>OK, I get a collision?</span>
  </p><p><span m=''4150000''>Yeah? If it''s a permutation,</span> <span m=''4154778''>you''re
  not, right? Something like that.</span> </p><p><span m=''4161504''>What is it exactly?
  So, that''s the question.</span> </p><p><span m=''4170000''>OK, so you are not going
  to hit the same slot because it''s going</span> <span m=''4175478''>to be a permutation.
  Yeah?</span> </p><p><span m=''4177652''>That''s exactly right. n minus one over
  m minus one</span> <span m=''4181913''>because I''m now, I''ve essentially eliminated</span>
  <span m=''4185652''>that slot that I hit the first time.</span> </p><p><span m=''4188694''>And
  so, I have, now, and there was a key there.</span> </p><p><span m=''4192694''>So,
  now I''m essentially looking, at random,</span> <span m=''4196347''>into the remaining
  n minus one slots where there are</span> <span m=''4200782''>aggregately n minus
  one keys in those slots.</span> </p><p><span m=''4206000''>OK, everybody got that?
  OK, so with that probability,</span> <span m=''4211306''>I get a collision. That
  means that I need a third</span> <span m=''4216204''>probe necessary, OK?</span>
  </p><p><span m=''4218142''>And, we keep going on. OK, so what is it going to be</span>
  <span m=''4223346''>the next time? Yeah, it''s going to be n minus</span> <span
  m=''4227836''>two over m minus two. So, let''s note,</span> <span m=''4233939''>OK,
  that n minus i over m minus i is less than n over m,</span> <span m=''4244716''>which
  equals alpha, OK?</span> </p><p><span m=''4249027''>So, n minus i over m minus i
  is less than n over m.</span> </p><p><span m=''4260000''>And, the way you can sort
  of reason that is that if n is less</span> <span m=''4265505''>than m, I''m subtracting
  a larger fraction of n when I subtract i</span> <span m=''4271287''>than I am subtracting
  a fraction of m.</span> </p><p><span m=''4274682''>OK, so therefore, n minus i over
  m minus i is</span> <span m=''4278720''>going to be less than n over m. OK, so,
  or you can do the</span> <span m=''4283858''>algebra. I think it''s always helpful</span>
  <span m=''4287070''>when you do algebra to sort of think about it sort of</span>
  <span m=''4291842''>quantitatively as well, you know, qualitatively what''s</span>
  <span m=''4296705''>going on. So, the expected number of</span> <span m=''4302119''>probes
  is, then, going to be equal to,</span> <span m=''4306559''>it''s going to be equal
  to because we''re going to need some</span> <span m=''4313399''>space, well, we
  have one which is forced because we''ve got to</span> <span m=''4320600''>do one
  probe, plus with probability n over m,</span> <span m=''4329308''>I have to do another
  probe plus with probability of n over m</span> <span m=''4341313''>minus one I have
  to do another probe up until I do one plus one</span> <span m=''4353930''>over m
  minus n. OK, so each one is cascading</span> <span m=''4360276''>what''s happened.
  In the book,</span> <span m=''4362553''>there is a more rigorous proof of this using
  indicator random</span> <span m=''4367432''>variables. I''m going to give you the
  short</span> <span m=''4370767''>version. OK, so basically,</span> <span m=''4372800''>this
  is my first probe. With probability n over m,</span> <span m=''4376784''>I had to
  do a second one. And, the result of that is that</span> <span m=''4381338''>with
  probability n minus one over m minus one,</span> <span m=''4384997''>I have to do
  another. And, with probability n over</span> <span m=''4388982''>two minus m over
  two, I have to do another,</span> <span m=''4392397''>and so forth. So, that''s
  how many probes I''m</span> <span m=''4398857''>going to end up doing. So, this
  is less than or equal</span> <span m=''4405542''>to one plus alpha. There''s one
  plus alpha times</span> <span m=''4411457''>one plus alpha times one plus alpha,
  OK, just using the fact</span> <span m=''4419042''>that I had here. OK, and that
  is less than or</span> <span m=''4425536''>equal to one plus I just multiply through
  here.</span> </p><p><span m=''4431347''>Alpha plus alpha squared plus alpha cubed
  plus k.</span> </p><p><span m=''4437410''>I can just take that out to infinity.</span>
  </p><p><span m=''4441957''>It''s going to bound this. OK, does everybody see the
  math</span> <span m=''4450206''>there? OK, and that is just the sum,</span> <span
  m=''4454954''>I, equals zero to infinity, alpha to the I,</span> <span m=''4460653''>which
  is equal to one over one minus alpha using your familiar</span> <span m=''4468929''>geometric
  series bound. OK, and there''s also,</span> <span m=''4474615''>in the textbook,
  an analysis of the successful</span> <span m=''4478076''>search, which, once again,
  is a little bit</span> <span m=''4481230''>more technical because you have to worry
  about what the</span> <span m=''4485384''>distribution is that you happen to have
  in the table when you</span> <span m=''4490000''>are searching for something that''s
  already in the table.</span> </p><p><span m=''4494230''>But, it turns out it''s
  also bounded by one over one minus</span> <span m=''4498538''>alpha. So, let''s
  just look to see what</span> <span m=''4504920''>that means. So, if alpha is less
  than one</span> <span m=''4511269''>is a constant, it implies that it takes order</span>
  <span m=''4518253''>one probes. OK, so if alpha is a constant,</span> <span m=''4524761''>it
  takes order one probes. OK, but it''s helpful to</span> <span m=''4533621''>understand
  what''s happening with the constant.</span> </p><p><span m=''4540706''>So, for example,
  if the table is 50% full,</span> <span m=''4547161''>so alpha is a half, what''s
  the expected number of</span> <span m=''4554719''>probes by this analysis? Two,
  because one over one minus</span> <span m=''4563378''>a half is two. If I let the
  table fill up to</span> <span m=''4571531''>90%, how many probes do I need on average?</span>
  </p><p><span m=''4577937''>Ten. So, you can see that as you</span> <span m=''4582781''>fill
  up the table, the cost is going dramatically,</span> <span m=''4590437''>OK? And
  so, typically,</span> <span m=''4593955''>you don''t let the table get too full.</span>
  </p><p><span m=''4597865''>OK, you don''t want to be pushing 99.9% utilization.</span>
  </p><p><span m=''4603297''>Oh, I got this great hash table that''s got full utilization.</span>
  </p><p><span m=''4609706''>It''s like, yeah, and it''s slow.</span> </p><p><span
  m=''4612964''>It''s really, really slow,</span> <span m=''4615571''>OK, because
  as alpha approaches one, the time is approaching and</span> <span m=''4622415''>essentially
  m, or n.</span> </p><p><span m=''4626000''>Good. So, next time,</span> <span m=''4628050''>we
  are going to address head-on in what was one of the most,</span> <span m=''4634419''>I
  think, interesting ideas in algorithms.</span> </p><p><span m=''4638737''>We are
  going to talk about how you solve this problem that no</span> <span m=''4645213''>matter
  what hash function you pick, there''s a bad set of keys.</span> </p><p><span m=''4651798''>OK,
  so next time we''re going to show that there are ways of</span> <span m=''4658058''>confronting
  that problem, very clever ways.</span> </p><p><span m=''4662592''>And we use a lot
  of math for it so will be a really fun lecture.</span> </p>'
type: course
uid: 038082bddaf2cd718a96f35effebed99

---
None