---
about_this_resource_text: <p><strong>Topics covered:</strong>&nbsp;Order Statistics,
  Median</p> <p><strong>Instructors:</strong>&nbsp;Prof. Erik Demaine,&nbsp;Prof.
  Charles Leiserson<br /> &nbsp;</p>
course_id: 6-046j-introduction-to-algorithms-sma-5503-fall-2005
embedded_media:
- id: lec6.pdf
  parent_uid: 6bf801941af370fec4ee856e8e874bcc
  technical_location: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-6-order-statistics-median/lec6.pdf
  title: lec6.pdf
  type: null
  uid: ca4e5673e2b64eacc5691cda564cba49
- id: 6_046J_lec06_th.jpg
  parent_uid: 6bf801941af370fec4ee856e8e874bcc
  technical_location: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-6-order-statistics-median/6_046J_lec06_th.jpg
  title: 6_046J_lec06_th.jpg
  type: null
  uid: c9c804d45e58c1e8ad08f8e09daeb493
- id: Video-YouTube-Stream
  media_location: mR_RUjsJnV8
  parent_uid: 6bf801941af370fec4ee856e8e874bcc
  title: Video-YouTube-Stream
  type: Video
  uid: 4daa4775ea500f7b5c72a8e3c83d84b8
- id: Thumbnail-YouTube-JPG
  media_location: https://img.youtube.com/vi/mR_RUjsJnV8/default.jpg
  parent_uid: 6bf801941af370fec4ee856e8e874bcc
  title: Thumbnail-YouTube-JPG
  type: Thumbnail
  uid: 97f96e44fd0b3006bc12f3f4943719d9
- id: Video-iTunesU-MP4
  media_location: https://itunes.apple.com/us/itunes-u/id341597754
  parent_uid: 6bf801941af370fec4ee856e8e874bcc
  title: Video-iTunes U-MP4
  type: Video
  uid: e7e52d25ec28836123479486c39b1f45
- id: Video-InternetArchive-MP4
  media_location: http://www.archive.org/download/MIT6.046JF05MPEG4/ocw-6.046-28sep2005-220k.mp4
  parent_uid: 6bf801941af370fec4ee856e8e874bcc
  title: Video-Internet Archive-MP4
  type: Video
  uid: 368bfd1eb1637f7233ae150d9c9f118a
- id: Video-iTunesU-MP3
  media_location: http://deimos3.apple.com/WebObjects/Core.woa/Browse/mit.edu.1298167185.01298167189.1303256308?i=2095225259
  parent_uid: 6bf801941af370fec4ee856e8e874bcc
  title: Video-iTunes U-MP3
  type: Video
  uid: 300d5487f1d086601fe9c77a32c27253
- id: Video-InternetArchive-MP3
  media_location: http://www.archive.org/download/MIT6.046JF05/ocw-6.046-28sep2005.mp3
  parent_uid: 6bf801941af370fec4ee856e8e874bcc
  title: Video-Internet Archive-MP3
  type: Video
  uid: 17f79fc54122e8e13d7451606ada26e8
- id: Video-VideoLecturesnet-Stream
  media_location: http://videolectures.net/mit6046jf05_introduction_algorithms/
  parent_uid: 6bf801941af370fec4ee856e8e874bcc
  title: Video-VideoLectures.net-Stream
  type: Video
  uid: 9ab2c736d0cd4f752adecbe4971a9c97
- id: Thumbnail-OCW-JPG
  parent_uid: 6bf801941af370fec4ee856e8e874bcc
  title: Thumbnail-OCW-JPG
  type: Thumbnail
  uid: c7c5d19db870a17e384052c9cd9d76b5
- id: 3Play-3PlayYouTubeid-MP4
  media_location: mR_RUjsJnV8
  parent_uid: 6bf801941af370fec4ee856e8e874bcc
  title: 3Play-3Play YouTube id
  type: 3Play
  uid: 297fb95cba8f95688384da1ad0cb327f
- id: mR_RUjsJnV8.srt
  parent_uid: 6bf801941af370fec4ee856e8e874bcc
  technical_location: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-6-order-statistics-median/mR_RUjsJnV8.srt
  title: 3play caption file
  type: null
  uid: 269a482262cad733182c9c2b887d4e95
- id: mR_RUjsJnV8.pdf
  parent_uid: 6bf801941af370fec4ee856e8e874bcc
  technical_location: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-6-order-statistics-median/mR_RUjsJnV8.pdf
  title: 3play pdf file
  type: null
  uid: c0fb16b38fa759cef295c7b3da11cb4f
- id: Caption-3Play YouTube id-SRT
  parent_uid: 6bf801941af370fec4ee856e8e874bcc
  title: Caption-3Play YouTube id-SRT-English - US
  type: Caption
  uid: af816440f4d757872384058b3deab46c
- id: Transcript-3Play YouTube id-PDF
  parent_uid: 6bf801941af370fec4ee856e8e874bcc
  title: Transcript-3Play YouTube id-PDF-English - US
  type: Transcript
  uid: ec9961483ccaefb7c855d64c18830a02
inline_embed_id: 48759261lecture6:orderstatistics,median1530908
layout: video
order_index: null
parent_uid: c492612542f7cc7a09f73790a5f91d81
related_resources_text: <p>Lecture Notes (<a target="_blank" href="./resolveuid/ca4e5673e2b64eacc5691cda564cba49">PDF</a>)<br
  />             <a target="_blank" href="./resolveuid/efc69ef86c18e164d675bd8808c6477a">Assignments</a><br
  />             <a target="_blank" href="./resolveuid/144d9e513546eac8c1fd9b0d278e6eb2">Exams</a></p>
short_url: lecture-6-order-statistics-median
technical_location: https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-6-order-statistics-median
template_type: Tabbed
title: 'Lecture 6: Order Statistics, Median'
transcript: "<p><span m='5000'>The third step,</span> <span m='7000'>So, there is\
  \ a lot of Today we're going to not talk about sorting.</span> <span m='11000'>This\
  \ is an exciting new development. We know that what we're looking</span> <span m='14000'>We're\
  \ going to talk about another problem,</span> <span m='18000'>a related problem,\
  \ but a different problem.</span> <span m='35000'>We're going to talk about another\
  \ problem that we would</span> <span m='38000'>like to solve in linear time. Last\
  \ class we talked about we</span> <span m='41000'>could do sorting in linear time.\
  \ To do that we needed some</span> <span m='44000'>additional assumptions. Today\
  \ we're going to look at a</span> <span m='47000'>problem that really only needs\
  \ linear time, even though at</span> <span m='51000'>first glance it might look\
  \ like it requires sorting.</span> <span m='54000'>So this is going to be an easier\
  \ problem.</span> <span m='56000'>The problem is I give you a bunch of numbers.</span>\
  \ <span m='60000'>Let's call them elements. And they are in some array,</span> <span\
  \ m='66000'>let's say. And they're in no particular</span> <span m='71000'>order,\
  \ so unsorted. I want to find the kth smallest</span> <span m='78000'>element.</span>\
  \ <span m='86000'>This is called the element of rank k.</span> <span m='97000'>In\
  \ other words, I have this list of numbers</span> <span m='99000'>which is unsorted.\
  \ And, if I were to sort it,</span> <span m='103000'>I would like to know what the\
  \ kth element is.</span> <span m='106000'>But I'm not allowed to sort it. One solution\
  \ to this problem,</span> <span m='110000'>this is the na\xD4ve algorithm, is you\
  \ just sort and then</span> <span m='114000'>return the kth element. This is another\
  \ possible</span> <span m='117000'>definition of the problem. And we would like\
  \ to do better</span> <span m='123000'>than that. So you could sort,</span> <span\
  \ m='125000'>what's called the array A, and then return A[k].</span> <span m='130000'>That\
  \ is one thing we could do. And if we use heap sort or</span> <span m='136000'>mergesort,\
  \ this will take n lg n time.</span> <span m='140000'>We would like to do better\
  \ than n lg n.</span> <span m='143000'>Ideally linear time. The problem is pretty\
  \ natural,</span> <span m='149000'>straightforward. It has various applications.</span>\
  \ <span m='154000'>Depending on how you choose k, k could be any number between\
  \ 1</span> <span m='159000'>and n. For example,</span> <span m='161000'>if we choose\
  \ k=1 that element has a name.</span> <span m='164000'>Any suggestions of what the\
  \ name is?</span> <span m='167000'>The minimum. That's easy.</span> <span m='170000'>Any\
  \ suggestions on how we could find the minimum element in an</span> <span m='175000'>array\
  \ in linear time? Right.</span> <span m='179000'>Just scan through the array. Keep\
  \ track of what the smallest</span> <span m='184000'>number is that you've seen.\
  \ The same thing with the</span> <span m='188000'>maximum, k=n. These are rather\
  \ trivial.</span> <span m='192000'>But a more interesting version of the order statistic\
  \ problem</span> <span m='197000'>is to find the median. This is either k equals\
  \ n plus</span> <span m='201000'>1 over 2 floor or ceiling. I will call both of\
  \ those</span> <span m='206000'>elements medians.</span> <span m='214000'>Finding\
  \ the median of an unsorted array in linear time is</span> <span m='217000'>quite\
  \ tricky. And that sort of is the main</span> <span m='219000'>goal of this lecture,\
  \ is to be able to find the</span> <span m='221000'>medians. For free we're going\
  \ to be able</span> <span m='223000'>to find the arbitrary kth smallest element,</span>\
  \ <span m='226000'>but typically we're most interested in finding the</span> <span\
  \ m='228000'>median. And on Friday in recitation</span> <span m='230000'>you'll\
  \ see why that is so useful.</span> <span m='232000'>There are all sorts of situations\
  \ where you can use</span> <span m='235000'>median for really effective divide-and-conquer\
  \ without</span> <span m='238000'>having to sort. You can solve a lot of problems</span>\
  \ <span m='242000'>in linear time as a result. And we're going to cover today</span>\
  \ <span m='247000'>two algorithms for finding order statistics.</span> <span m='250000'>Both\
  \ of them are linear time. The first one is randomized,</span> <span m='255000'>so\
  \ it's only linear expected time.</span> <span m='258000'>And the second one is\
  \ worst-case linear time,</span> <span m='261000'>and it will build on the randomized\
  \ version.</span> <span m='265000'>Let's start with a randomize divide-and-conquer\
  \ algorithm.</span> <span m='286000'>This algorithm is called rand-select.</span>\
  \ <span m='302000'>And the parameters are a little bit more than what we're used</span>\
  \ <span m='306000'>to. The order statistics problem</span> <span m='308000'>you're\
  \ given an array A. And here I've changed notation</span> <span m='312000'>and I'm\
  \ looking for the ith smallest element,</span> <span m='315000'>so i is the index\
  \ I'm looking for.</span> <span m='318000'>And I'm also going to change the problem\
  \ a little bit.</span> <span m='321000'>And instead of trying to find it in the\
  \ whole array,</span> <span m='325000'>I'm going to look in a particular interval\
  \ of the</span> <span m='329000'>array, A from p up to q. We're going to need that\
  \ for a</span> <span m='333000'>recursion. This better be a recursive</span> <span\
  \ m='336000'>algorithm because we're using divide-and-conquer.</span> <span m='339000'>Here\
  \ is the algorithm.</span> <span m='351000'>With a base case. It's pretty simple.</span>\
  \ <span m='354000'>Then we're going to use part of the quicksort algorithm,</span>\
  \ <span m='360000'>randomized quicksort.</span> <span m='369000'>We didn't actually\
  \ define this subroutine two lectures ago,</span> <span m='373000'>but you should\
  \ know what it does, especially if you've read</span> <span m='377000'>the textbook.\
  \ This says in the array A[p...q]</span> <span m='380000'>pick a random element,\
  \ so pick a random index between</span> <span m='384000'>p and q, swap it with the\
  \ first element, then call partition.</span> <span m='390000'>And partition uses\
  \ that first element to split the rest of the</span> <span m='394000'>array into\
  \ less than or equal to that random partition and</span> <span m='399000'>greater\
  \ than or equal to that partition.</span> <span m='402000'>This is just picking\
  \ a random partition element between p and</span> <span m='407000'>q, cutting the\
  \ array in half, although the two sizes may not</span> <span m='412000'>be equal.\
  \ And it returns the index of</span> <span m='414000'>that partition element, some\
  \ number between p and q.</span> <span m='420000'>And we're going to define k to\
  \ be this particular value,</span> <span m='428000'>r minus p plus 1. And the reason\
  \ for that is that</span> <span m='435000'>k is then the rank of the partition element.</span>\
  \ <span m='441000'>This is in A[p...q]. Let me draw a picture here.</span> <span\
  \ m='450000'>We have our array A. It starts at p and ends at q.</span> <span m='454000'>There\
  \ is other stuff, but for this recursive all we</span> <span m='458000'>care about\
  \ is p up to q. We pick a random partition</span> <span m='462000'>element, say\
  \ this one, and we partition things so that</span> <span m='467000'>everything in\
  \ here, let's call this r,</span> <span m='470000'>is less than or equal to A[r]\
  \ and everything up here is</span> <span m='475000'>greater than or equal to A[r].\
  \ And A[r] is our partition</span> <span m='480000'>element. After this call,</span>\
  \ <span m='483000'>that's what the array looks like.</span> <span m='486000'>And\
  \ we get r. We get the index of where</span> <span m='489000'>partition element\
  \ is stored. The number of elements that are</span> <span m='494000'>less than or\
  \ equal to A[r] and including r is r minus p plus 1.</span> <span m='500000'>There\
  \ will be r minus p elements here,</span> <span m='503000'>and we're adding 1 to\
  \ get this element.</span> <span m='508000'>And, if you start counting at 1, if\
  \ this is rank 1,</span> <span m='512000'>rank 2, this element will have rank k.</span>\
  \ <span m='515000'>That's just from the construction in the partition.</span> <span\
  \ m='520000'>And now we get to recurse. And there are three cases --</span> <span\
  \ m='533000'>-- depending on how i relates to k.</span> <span m='535000'>Remember\
  \ i is the rank that we're looking for,</span> <span m='537000'>k is the rank that\
  \ we happen to get out of this random</span> <span m='541000'>partition. We don't\
  \ have much control over</span> <span m='543000'>k, but if we're lucky i=k. That's\
  \ the element we want.</span> <span m='553000'>Then we just return the partition\
  \ element.</span> <span m='555000'>More likely is that the element we're looking\
  \ for is either to</span> <span m='558000'>the left or to the right. And if it's\
  \ to the left we're</span> <span m='560000'>going to recurse in the left-hand portion\
  \ of the array.</span> <span m='563000'>And if it's to the right we're going to\
  \ recurse in the</span> <span m='566000'>right-hand portion. So, pretty straightforward\
  \ at</span> <span m='568000'>this point.</span> <span m='585000'>I just have to\
  \ get all the indices right.</span> <span m='608000'>Either we're going to recurse\
  \ on the part between p and r</span> <span m='611000'>minus 1, that's this case.\
  \ The rank we're looking for is</span> <span m='614000'>to the left of the rank\
  \ of element A[r].</span> <span m='617000'>Or, we're going to recurse on the right\
  \ part between r plus 1</span> <span m='620000'>and q. Where we recurse on the left</span>\
  \ <span m='622000'>part the rank we're looking for remains the same,</span> <span\
  \ m='625000'>but when we recurse on the right part the rank we're</span> <span m='628000'>looking\
  \ for gets offset. Because we sort of got rid of</span> <span m='633000'>the k elements\
  \ over here. I should have written this</span> <span m='638000'>length is k. We've\
  \ sort of swept away k</span> <span m='642000'>ranks of elements. And now within\
  \ this array we're</span> <span m='646000'>looking for the i minus kth smallest\
  \ element.</span> <span m='651000'>That's the recursion. We only recurse once.</span>\
  \ <span m='655000'>And random partition is not a recursion.</span> <span m='660000'>That\
  \ just takes linear time. And the total amount of work</span> <span m='664000'>we're\
  \ doing here should be linear time plus one recursion.</span> <span m='669000'>And\
  \ we'd next like to see what the total running time is in</span> <span m='674000'>expectation,\
  \ but let's first do a little example --</span> <span m='686000'>-- to make this\
  \ algorithm perfectly clear.</span> <span m='689000'>Let's suppose we're looking\
  \ for the seventh smallest element in</span> <span m='693000'>this array.</span>\
  \ <span m='710000'>And let's suppose, just for example,</span> <span m='713000'>that\
  \ the pivot we're using is just the first element.</span> <span m='717000'>So, nothing\
  \ fancy. I would have to flip a few</span> <span m='722000'>coins in order to generate\
  \ a random one, so let's just pick</span> <span m='726000'>this one. If I partition\
  \ at the element</span> <span m='729000'>6, this is actually an example we did two\
  \ weeks ago,</span> <span m='733000'>and I won't go through it again, but we get\
  \ the same</span> <span m='737000'>array, as we did two weeks ago, namely 2, 5,</span>\
  \ <span m='741000'>3, 6, 8, 13, 10 and 11.</span> <span m='743000'>If you run through\
  \ the partitioning algorithm,</span> <span m='746000'>that happens to be the order\
  \ that it throws the elements</span> <span m='751000'>into. And this is our position\
  \ r.</span> <span m='755000'>This is p here. It's just 1.</span> <span m='757000'>And\
  \ q is just the end. And I am looking for the</span> <span m='760000'>seventh smallest\
  \ element. And it happens when I run this</span> <span m='764000'>partition that\
  \ 6 falls into the fourth place.</span> <span m='768000'>And we know that means,\
  \ because all the elements here</span> <span m='772000'>are less than 6 and all\
  \ the elements here are greater than</span> <span m='776000'>6, if this array were\
  \ sorted, 6 would be right here in</span> <span m='780000'>position four. So, r\
  \ here is 4.</span> <span m='785000'>Yeah? The 12 turned into an 11?</span> <span\
  \ m='789000'>This was an 11, believe it or not.</span> <span m='793000'>Let me be\
  \ simple. Sorry.</span> <span m='796000'>Sometimes my ones look like twos.</span>\
  \ <span m='800000'>Not a good feature. That's an easy way to cover.</span> <span\
  \ m='807000'>[LAUGHTER] Don't try that on exams.</span> <span m='811000'>Oh, that\
  \ one was just a two. No.</span> <span m='813000'>Even though we're not sorting\
  \ the array, we're only spending</span> <span m='817000'>linear work here to partition\
  \ by</span> <span m='819000'>We know that if we had sorted the array 6 would fall\
  \ here.</span> <span m='823000'>We don't know about these other elements.</span>\
  \ <span m='826000'>They're not in sorted order, but from the properties of</span>\
  \ <span m='829000'>partition we know 6 went the right spot.</span> <span m='832000'>We\
  \ now know rank of 6 is 4. We happened to be looking for 7</span> <span m='836000'>and\
  \ we happened to get this number 4.</span> <span m='840000'>We want something over\
  \ here. It turns out we're looking for</span> <span m='843000'>10, I guess. No,\
  \ 11.</span> <span m='845000'>There should be eight elements in this array,</span>\
  \ <span m='848000'>so it's the next to max. Max here is 13,</span> <span m='850000'>I'm\
  \ cheating here. The answer we're looking for is</span> <span m='856000'>for is\
  \ in the right-hand part because the rank we're looking</span> <span m='860000'>for\
  \ is 7, which is bigger than</span> <span m='862000'>Now, what rank are we looking\
  \ for in here?</span> <span m='865000'>Well, we've gotten rid of four elements over\
  \ here.</span> <span m='870000'>It happened here that k is also 4 because p is 1\
  \ in this</span> <span m='875000'>example. The rank of 6 was 4.</span> <span m='878000'>We\
  \ throw away those four elements.</span> <span m='881000'>Now we're looking for\
  \ rank 7 minus 4 which is 3.</span> <span m='886000'>And, indeed, the rank 3 element\
  \ here is</span> <span m='889000'>still 11. So, you recursively find that.</span>\
  \ <span m='893000'>That's your answer. Now that algorithm should be</span> <span\
  \ m='898000'>pretty clear. The tricky part is to analyze</span> <span m='903000'>it.\
  \ And the analysis here is quite</span> <span m='905000'>a bit like randomized quicksort,\
  \ although not quite as hairy,</span> <span m='910000'>so it will go faster. But\
  \ it will be also sort of a</span> <span m='913000'>nice review of the randomized\
  \ quicksort analysis which was a</span> <span m='918000'>bit tricky and always good\
  \ to see a couple of times.</span> <span m='921000'>We're going to follow the same\
  \ kind of outline as before to</span> <span m='926000'>look at the expected running\
  \ time of this algorithm.</span> <span m='931000'>And to start out we're going to,\
  \ as before,</span> <span m='934000'>look at some intuition just to feel good about\
  \ ourselves.</span> <span m='939000'>Also feel bad as you'll see. Let's think about\
  \ two sort of</span> <span m='944000'>extreme cases, a good case and the worst case.</span>\
  \ <span m='949000'>And I should mention that in all of the analyses today we</span>\
  \ <span m='954000'>assume the elements are distinct.</span> <span m='964000'>It\
  \ gets really messy if the elements are not distinct.</span> <span m='968000'>And\
  \ you may even have to change the algorithms a little bit</span> <span m='972000'>because\
  \ if all the elements are equal, if you pick a random</span> <span m='976000'>element,\
  \ the partition does not do so well.</span> <span m='979000'>But let's assume they're\
  \ all distinct, which is the really</span> <span m='984000'>interesting case. A\
  \ pretty luck case --</span> <span m='988000'>I mean the best cases we partition\
  \ right in the middle.</span> <span m='992000'>The number of elements to the left\
  \ of our partition is equal</span> <span m='997000'>to the number of elements to\
  \ the right of our partition.</span> <span m='1002000'>But almost as good would\
  \ be some kind of 1/10 to 9/10 split.</span> <span m='1007000'>Any constant fraction,\
  \ we should feel that.</span> <span m='1010000'>Any constant fraction is as good\
  \ as 1/2.</span> <span m='1014000'>Then the recurrence we get is, let's say at most,</span>\
  \ <span m='1018000'>this bad. So, it depends.</span> <span m='1021000'>If we have\
  \ let's say 1/10 on the left and 9/10 on the right</span> <span m='1024000'>every\
  \ time we do a partition. It depends where our answer is.</span> <span m='1028000'>It\
  \ could be if i is really small it's in the 1/10 part.</span> <span m='1032000'>If\
  \ i is really big it's going to be in the 9/10 part,</span> <span m='1036000'>or\
  \ most of the time it's going to be in the 9/10 part.</span> <span m='1039000'>We're\
  \ doing worst-case analysis within the lucky case,</span> <span m='1043000'>so we're\
  \ happy to have upper bounds.</span> <span m='1045000'>I will say t(n) is at most\
  \ t of T(9/10n)+Theta(n).</span> <span m='1050000'>Clearly it's worse if we're in\
  \ the bigger part.</span> <span m='1054000'>What is the solution to this recurrence?</span>\
  \ <span m='1058000'>Oh, solving recurrence was so long ago.</span> <span m='1062000'>What\
  \ method should we use for solving this recurrence?</span> <span m='1067000'>The\
  \ master method. What case are we in?</span> <span m='1071000'>Three. Good.</span>\
  \ <span m='1072000'>You still remember. This is Case 3.</span> <span m='1075000'>We're\
  \ looking at nlog_b(a). b here is 10/9,</span> <span m='1081000'>although it doesn't\
  \ really matter because a is 1.</span> <span m='1086000'>log base anything of 1\
  \ is 0. So, this is n^0 which is 1.</span> <span m='1091000'>And n is polynomially\
  \ larger than 1.</span> <span m='1094000'>This is going to be O(n), which is good.</span>\
  \ <span m='1098000'>That is what we want, linear time.</span> <span m='1101000'>If\
  \ we're in the lucky case, great.</span> <span m='1105000'>Unfortunately this is\
  \ only intuition.</span> <span m='1110000'>And we're not always going to get the\
  \ lucky case.</span> <span m='1112000'>We could do the same kind of analysis as\
  \ we did with</span> <span m='1115000'>randomized quicksort. If you alternate between\
  \ lucky</span> <span m='1118000'>and unlucky, things will still be good, but let's\
  \ just talk</span> <span m='1121000'>about the unlucky case to show how bad things\
  \ can get.</span> <span m='1124000'>And this really would be a worst-case analysis.</span>\
  \ <span m='1133000'>The unlucky case we get a split of 0:n-1.</span> <span m='1140000'>Because\
  \ we're removing the partition element either way.</span> <span m='1144000'>And\
  \ there could be nothing less than the partition element.</span> <span m='1149000'>We\
  \ have 0 on the left-hand side and we have n-1 on the</span> <span m='1154000'>right-hand\
  \ side. Now we get a recurrence like</span> <span m='1158000'>T(n)=T(n-1) plus linear\
  \ cost. And what's the solution to that</span> <span m='1163000'>recurrence? n^2.</span>\
  \ <span m='1165000'>Yes. This one you should just know.</span> <span m='1167000'>It's\
  \ n^2 because it's an arithmetic series.</span> <span m='1178000'>And that's pretty\
  \ bad. This is much,</span> <span m='1180000'>much worse than sorting and then picking\
  \ the ith element.</span> <span m='1183000'>In the worst-case this algorithm really\
  \ sucks,</span> <span m='1186000'>but most of the time it's going to do really well.</span>\
  \ <span m='1189000'>And, unless you're really, really unlucky and every coin</span>\
  \ <span m='1192000'>you flip gives the wrong answer, you won't get this case and\
  \ you</span> <span m='1196000'>will get something more like the lucky case.</span>\
  \ <span m='1198000'>At least that's what we'd like to prove.</span> <span m='1202000'>And\
  \ we will prove that the expected running time here is</span> <span m='1205000'>linear.\
  \ So, it's very rare to get</span> <span m='1207000'>anything quadratic. But later\
  \ on we will see how to</span> <span m='1209000'>make the worst-case linear as well.</span>\
  \ <span m='1211000'>This would really, really solve the problem.</span> <span m='1230000'>Let's\
  \ get into the analysis.</span> <span m='1243000'>Now, you've seen an analysis much\
  \ like this before.</span> <span m='1247000'>What do you suggest we do in order\
  \ to analyze this expected</span> <span m='1251000'>time? It's a divide-and-conquer</span>\
  \ <span m='1254000'>algorithm, so we kind of like to write down the recurrence on</span>\
  \ <span m='1259000'>something resembling the running time.</span> <span m='1269000'>I\
  \ don't need the answer, but what's the first step that</span> <span m='1272000'>we\
  \ might do to analyze the expected running time of this</span> <span m='1276000'>algorithm?\
  \ Sorry?</span> <span m='1278000'>Look at different cases, yeah.</span> <span m='1280000'>Exactly.\
  \ We have all these possible ways</span> <span m='1282000'>that random partition\
  \ could split.</span> <span m='1285000'>It could split 0 to the n-1. It could split\
  \ in half.</span> <span m='1290000'>There are n choices where it could split.</span>\
  \ <span m='1293000'>How can we break into those cases?</span> <span m='1295000'>Indicator\
  \ random variables. Cool.</span> <span m='1298000'>Exactly. That's what we want\
  \ to do.</span> <span m='1301000'>Indicator random variable suggests that what we're\
  \ dealing</span> <span m='1306000'>with is not exactly just a function T(n) but\
  \ it's a random</span> <span m='1310000'>variable. This is one subtlety.</span>\
  \ <span m='1313000'>T(n) depends on the random choices, so it's really a random</span>\
  \ <span m='1317000'>variable.</span> <span m='1325000'>And then we're going to use\
  \ indicator random variables to</span> <span m='1328000'>get a recurrence on T(n).</span>\
  \ <span m='1345000'>So, T(n) is the running time of rand-select on an input of size</span>\
  \ <span m='1352000'>n.</span> <span m='1360000'>And I am also going to write down\
  \ explicitly an assumption</span> <span m='1366000'>about the random numbers.</span>\
  \ <span m='1375000'>That they should be chosen independently from each other.</span>\
  \ <span m='1380000'>Every time I call random partition, it's generating a</span>\
  \ <span m='1383000'>completely independent random number from all the other times</span>\
  \ <span m='1387000'>I call random partition. That is important,</span> <span m='1390000'>of\
  \ course, for this analysis to work.</span> <span m='1392000'>We will see why some\
  \ point down the line.</span> <span m='1395000'>And now, to sort of write down an\
  \ equation for T(n) we're going</span> <span m='1399000'>to define indicator random\
  \ variables, as you suggested.</span> <span m='1416000'>And we will call it X_k.\
  \ And this is for all k=0...n-1.</span> <span m='1430000'>Indicator random variables\
  \ either 1 or 0.</span> <span m='1434000'>And it's going to be 1 if the partition\
  \ comes out k on the</span> <span m='1440000'>left-hand side. So say the partition\
  \ generates</span> <span m='1446000'>a k:n-k-1 split and it is 0 otherwise.</span>\
  \ <span m='1451000'>We have n of these indicator random variables between</span>\
  \ <span m='1457000'>0...n-1. And in each case,</span> <span m='1460000'>no matter\
  \ how the random choice comes out, exactly one of them</span> <span m='1467000'>will\
  \ be 1. All the others will be 0.</span> <span m='1472000'>Now we can divide out\
  \ the running time of this algorithm</span> <span m='1477000'>based on which case\
  \ we're in.</span> <span m='1489000'>That will sort of unify this intuition that\
  \ we did and get</span> <span m='1497000'>all the cases. And then we can look at\
  \ the</span> <span m='1502000'>expectation. T(n), if we just split out by</span>\
  \ <span m='1508000'>cases, we have an upper bound like this.</span> <span m='1528000'>If\
  \ we have 0 to n-1 split, the worst is we have n-1.</span> <span m='1533000'>Then\
  \ we have to recurse in a problem of size n-1.</span> <span m='1538000'>In fact,\
  \ it would be pretty hard to recurse in a problem of</span> <span m='1543000'>size\
  \ 0. If we have a 1 to n-2 split</span> <span m='1547000'>then we take the max of\
  \ the two sides.</span> <span m='1551000'>That's certainly going to give us an upper\
  \ bound and so on.</span> <span m='1563000'>And at the bottom you get an n-1 to\
  \ 0 split.</span> <span m='1574000'>This is now sort of conditioning on various\
  \ events,</span> <span m='1576000'>but we have indicator random variables to tell\
  \ us when these</span> <span m='1579000'>events happen. We can just multiply each\
  \ of</span> <span m='1581000'>these values by the indicator random variable and\
  \ it will come</span> <span m='1585000'>out 0 if that's not the case and will come\
  \ out 1 and give us this</span> <span m='1588000'>value if that happens to be the\
  \ split.</span> <span m='1591000'>So, if we add up all of those we'll get the same\
  \ thing.</span> <span m='1597000'>This is equal to the sum over all k of the indicator\
  \ random</span> <span m='1605000'>variable times the cost in that case, which is\
  \ t of max k,</span> <span m='1612000'>and the other side, which is n-k-1,</span>\
  \ <span m='1617000'>plus theta n. This is our recurrence,</span> <span m='1621000'>in\
  \ some sense, for the random variable</span> <span m='1624000'>representing running\
  \ time. Now, the value will depend on</span> <span m='1629000'>which case we come\
  \ into. We know the probability of each</span> <span m='1633000'>of these events\
  \ happening is the same because we're choosing the</span> <span m='1639000'>partition\
  \ element uniformly at random, but we cannot really</span> <span m='1643000'>simplify\
  \ much beyond this until we take expectations.</span> <span m='1649000'>We know\
  \ this random variable could be as big as n^2.</span> <span m='1652000'>Hopefully\
  \ it's usually linear. We will take expectations of</span> <span m='1657000'>both\
  \ sides and get what we want.</span> <span m='1674000'>Let's look at the expectation\
  \ of this random variable,</span> <span m='1678000'>which is just the expectation,\
  \ I will copy over,</span> <span m='1682000'>summation we have here so I can work\
  \ on this board.</span> <span m='1710000'>I want to compute the expectation of this\
  \ summation.</span> <span m='1713000'>What property of expectation should I use?</span>\
  \ <span m='1716000'>Linearity, good. We can bring the summation</span> <span m='1719000'>outside.</span>\
  \ <span m='1748000'>Now I have a sum of expectation.</span> <span m='1749000'>Let's\
  \ look at each expectation individually.</span> <span m='1752000'>It's a product\
  \ of two random variables, if you will.</span> <span m='1755000'>This is an indicator\
  \ random variable and this is some more</span> <span m='1759000'>complicated function,\
  \ some more complicated random</span> <span m='1762000'>variable representing some\
  \ running time,</span> <span m='1764000'>which depends on what random choices are\
  \ made in that</span> <span m='1768000'>recursive call. Now what should I do?</span>\
  \ <span m='1771000'>I have the expectation of the product of two random variables.</span>\
  \ <span m='1777000'>Independence, exactly.</span> <span m='1779000'>If I know that\
  \ these two random variables are independent then I</span> <span m='1785000'>know\
  \ that the expectation of the product is the product of the</span> <span m='1791000'>expectations.\
  \ Now we have to check are they</span> <span m='1795000'>independent? I hope so\
  \ because otherwise</span> <span m='1798000'>there isn't much else I can do. Why\
  \ are they independent?</span> <span m='1804000'>Sorry? Because we stated that they</span>\
  \ <span m='1807000'>are, right. Because of this assumption.</span> <span m='1810000'>We\
  \ assume that all the random numbers are chosen</span> <span m='1814000'>independently.\
  \ We need to sort of interpolate</span> <span m='1817000'>that here. These X_k's,</span>\
  \ <span m='1819000'>all the X_k's, X_0 up to X_n-1,</span> <span m='1821000'>so\
  \ all the ones appearing in this summation are dependent</span> <span m='1826000'>upon\
  \ a single random choice of this particular call to random</span> <span m='1830000'>partition.\
  \ All of these are correlated,</span> <span m='1836000'>because if one of them is\
  \ 1, all the others are forced to be</span> <span m='1847000'>correlation among\
  \ the X_k's. But with respect to everything</span> <span m='1854000'>that is in\
  \ here, and the only random part is</span> <span m='1860000'>this T(max(kn-k-1)).\
  \ That is the reason that this</span> <span m='1867000'>random variable is independent\
  \ from these.</span> <span m='1872000'>The same thing as quicksort, but I know some\
  \ people got</span> <span m='1879000'>confused about it a couple lectures ago so\
  \ I am</span> <span m='1884000'>reiterating. We get the product of</span> <span\
  \ m='1889000'>expectations, E[X_k] E[T(max(kn-k-1))].</span> <span m='1895000'>I\
  \ mean the order n comes outside, but let's leave it</span> <span m='1900000'>inside\
  \ for now. There is no expectation to</span> <span m='1904000'>compute there for\
  \ order n. Order n is order n.</span> <span m='1909000'>What is the expectation\
  \ of X_k? 1/n, because they're all chosen</span> <span m='1915000'>with equal probability.\
  \ There is n of them,</span> <span m='1920000'>so the expectation is 1/n. The value\
  \ is either 1 or 0.</span> <span m='1924000'>We start to be able to split this up.</span>\
  \ <span m='1927000'>We have 1/n times this expected value of some recursive T call,</span>\
  \ <span m='1932000'>and then we have plus 1 over n times order n,</span> <span m='1935000'>also\
  \ known as a constant, but everything is summed up n</span> <span m='1940000'>times\
  \ so let's expand this.</span> <span m='1955000'>I have the sum k=0 to n-1. I guess\
  \ the 1/n can come</span> <span m='1962000'>outside. And we have expectation of</span>\
  \ <span m='1967000'>[T(max(kn-k-1))]. Lots of nifty braces there.</span> <span m='1974000'>And\
  \ then plus we have, on the other hand,</span> <span m='1979000'>the sum k=0 to\
  \ n-1. Let me just write that out</span> <span m='1986000'>again. We have a 1/n\
  \ in front and we</span> <span m='1988000'>have a Theta(n) inside. This summation\
  \ is n^2.</span> <span m='1992000'>And then we're dividing by n, so this whole thing\
  \ is,</span> <span m='1996000'>again, order n. Nothing fancy happened there.</span>\
  \ <span m='2000000'>This is really just saying the expectation of order n is order</span>\
  \ <span m='2005000'>n. Average value of order n is</span> <span m='2007000'>order\
  \ n. What is interesting is this</span> <span m='2011000'>part. Now, what could\
  \ we do with this</span> <span m='2015000'>summation? Here we start to differ from</span>\
  \ <span m='2018000'>randomized quicksort because we have this max.</span> <span\
  \ m='2023000'>Randomized quicksort we had the sum of T(k) plus T(n-k-1)</span> <span\
  \ m='2028000'>because we were making both recursive calls.</span> <span m='2032000'>Here\
  \ we're only making the biggest one.</span> <span m='2036000'>That max is really\
  \ a pain for evaluating this recurrence.</span> <span m='2043000'>How could I get\
  \ rid of the max? That's one way to think of it.</span> <span m='2051000'>Yeah?</span>\
  \ <span m='2058000'>Exactly. I could only sum up to halfway</span> <span m='2060000'>and\
  \ then double. In other words,</span> <span m='2063000'>terms are getting repeated\
  \ twice here.</span> <span m='2066000'>When k=0 or when k=n-1, I get the same T(n-1).</span>\
  \ <span m='2070000'>When k=1 or n-2, I get the same thing,</span> <span m='2073000'>2\
  \ and n-3. What I will actually do is sum</span> <span m='2077000'>from halfway\
  \ up. That's a little bit cleaner.</span> <span m='2082000'>And let me get the indices\
  \ right.</span> <span m='2085000'>Floor of n/2 up to n-1 will be safe.</span> <span\
  \ m='2089000'>And then I just have E[T(k)], except I forgot to multiply by</span>\
  \ <span m='2095000'>2, so I'm going to change this 1 to a 2.</span> <span m='2101000'>And\
  \ order n is preserved. This is just because each term</span> <span m='2104000'>is\
  \ appearing twice. I can factor it out.</span> <span m='2107000'>And if n is odd,\
  \ I'm actually double-counting</span> <span m='2110000'>somewhat, but it's certain\
  \ at most that.</span> <span m='2113000'>So, that's a safe upper bound. And upper\
  \ bounds are all we</span> <span m='2117000'>care about because we're hoping to\
  \ get linear.</span> <span m='2120000'>And the running time of this algorithm is\
  \ definitely at least</span> <span m='2124000'>linear, so we just need an upper\
  \ bounded linear.</span> <span m='2129000'>So, this is a recurrence. E[T(n)] is\
  \ at most 2/n times</span> <span m='2132000'>the sum of half the numbers between\
  \ 0 and n of</span> <span m='2136000'>E[T(k)]+Theta(n). It's a bit of hairy recurrence.</span>\
  \ <span m='2139000'>We want to solve it, though.</span> <span m='2141000'>And it's\
  \ actually a little bit easier than the randomized</span> <span m='2145000'>quicksort\
  \ recurrence. We're going to solve it.</span> <span m='2148000'>What method should\
  \ we use? Sorry?</span> <span m='2151000'>Master method? Master would be nice,</span>\
  \ <span m='2153000'>except that each of the recursive calls is with a</span> <span\
  \ m='2157000'>different value of k. The master method only works</span> <span m='2161000'>when\
  \ all the calls are with the same value, same size.</span> <span m='2165000'>Alas,\
  \ it would be nice if we could use the master method.</span> <span m='2169000'>What\
  \ else do we have? Substitution.</span> <span m='2171000'>When it's hard, when in\
  \ doubt,</span> <span m='2173000'>use substitution. I mean the good thing here is</span>\
  \ <span m='2176000'>we know what we want. From the intuition at least,</span> <span\
  \ m='2180000'>which is now erased, we really feel that this should</span> <span\
  \ m='2183000'>be linear time. So, we know what we want to</span> <span m='2186000'>prove.\
  \ And indeed we can prove it just</span> <span m='2191000'>directly with substitution.</span>\
  \ <span m='2202000'>I want to claim there is some constant c greater than zero</span>\
  \ <span m='2206000'>such that E[T(n)], according to this recurrence,</span> <span\
  \ m='2209000'>is at most c times n. Let's prove that over here.</span> <span m='2220000'>As\
  \ we guessed, the proof is by substitution.</span> <span m='2233000'>What that means\
  \ is we're going to assume, by induction,</span> <span m='2238000'>that this inequality\
  \ is true for all smaller m.</span> <span m='2242000'>I will just say 4 less than\
  \ n. And we need to prove it for n.</span> <span m='2248000'>We get E[T(n)]. Now\
  \ we are just going to expand</span> <span m='2253000'>using the recurrence that\
  \ we have.</span> <span m='2256000'>It's at most this. I will copy that over.</span>\
  \ <span m='2274000'>And then each of these recursive calls is with some</span> <span\
  \ m='2277000'>value k that is strictly smaller than n.</span> <span m='2280000'>Sorry,\
  \ I copied it wrong, floor of n over 2,</span> <span m='2283000'>not zero. And so\
  \ I can apply the</span> <span m='2287000'>induction hypothesis to each of these.</span>\
  \ <span m='2291000'>This is at most c times k by the induction hypothesis.</span>\
  \ <span m='2296000'>And so I get this inequality.</span> <span m='2317000'>This\
  \ c can come outside the summation because it's just a</span> <span m='2320000'>constant.\
  \ And I will be slightly tedious</span> <span m='2323000'>in writing this down again,\
  \ because what I care about is</span> <span m='2327000'>the summation here that\
  \ is left over.</span> <span m='2336000'>This is a good old-fashioned summation.</span>\
  \ <span m='2341000'>And if you remember back to your summation tricks or</span>\
  \ <span m='2344000'>whatever, you should be able to evaluate this.</span> <span\
  \ m='2347000'>If we started at zero and went up to n minus 1,</span> <span m='2351000'>that's\
  \ just an arithmetic series, but here we have the</span> <span m='2354000'>tail\
  \ end of an arithmetic series.</span> <span m='2356000'>And you should know, at\
  \ least up to theta,</span> <span m='2359000'>what this is, right?</span> <span\
  \ m='2361000'>n^2, yeah. It's definitely T(n^2).</span> <span m='2363000'>But we\
  \ need here a slightly better upper bond,</span> <span m='2366000'>as we will see\
  \ the constants really matter.</span> <span m='2371000'>What we're going to use\
  \ is that this summation is at most 3/8</span> <span m='2375000'>times n^2. And\
  \ that will be critical,</span> <span m='2378000'>the fact that 3/8 is smaller than\
  \ 1/2, I believe.</span> <span m='2381000'>So it's going to get rid of this 2.</span>\
  \ <span m='2384000'>I am not going to prove this. This is an exercise.</span> <span\
  \ m='2387000'>When you know that it is true, it's easy because you can just</span>\
  \ <span m='2392000'>prove it by induction. Figuring out that number is a</span>\
  \ <span m='2395000'>little bit more work, but not too much more.</span> <span m='2400000'>So\
  \ you should prove that by induction.</span> <span m='2404000'>Now let me simplify.\
  \ This is a bit messy,</span> <span m='2409000'>but what I want is c times n. Let's\
  \ write it as our desired</span> <span m='2415000'>value minus the residual. And\
  \ here we have some crazy</span> <span m='2422000'>fractions. This is 2 times 3\
  \ which is 6</span> <span m='2426000'>over 8 which is 3/4, right?</span> <span m='2431000'>Here\
  \ we have 1, so we have to subtract up 1/4</span> <span m='2434000'>to get 3/4.\
  \ And this should be,</span> <span m='2437000'>I guess, 1/4 times c times n. And\
  \ then we have this theta n</span> <span m='2442000'>with double negation becomes\
  \ a plus theta n.</span> <span m='2445000'>That should be clear. I am just rewriting\
  \ that.</span> <span m='2449000'>So we have what we want over here.</span> <span\
  \ m='2452000'>And then we hope that this is nonnegative because what we want</span>\
  \ <span m='2457000'>is that this less than or equal to c times n.</span> <span m='2463000'>That\
  \ will be true, provided this thing is</span> <span m='2466000'>nonnegative. And\
  \ it looks pretty good</span> <span m='2469000'>because we're free to choose c however\
  \ large we want.</span> <span m='2473000'>Whatever constant is imbedded in this\
  \ beta notation is one</span> <span m='2477000'>fixed constant, whatever makes this\
  \ recurrence</span> <span m='2481000'>true. We just set c to be bigger than</span>\
  \ <span m='2484000'>4 times that constant and then this will be nonnegative.</span>\
  \ <span m='2488000'>So this is true for c sufficiently large to dwarf that</span>\
  \ <span m='2492000'>theta constant. It's also the base case.</span> <span m='2496000'>I\
  \ just have to make the cursory mention that we choose c large</span> <span m='2501000'>enough\
  \ so that this claim is true, even in the base case</span> <span m='2505000'>where\
  \ n is at most some constant.</span> <span m='2508000'>Here it's like 1 or so because\
  \ then we're not making a</span> <span m='2512000'>recursive call. What we get --</span>\
  \ <span m='2515000'>This algorithm, randomize select,</span> <span m='2519000'>has\
  \ expected running time order n, Theta(n).</span> <span m='2532000'>The annoying\
  \ this is that in the worst-case,</span> <span m='2535000'>if you're really, really\
  \ unlucky it's n^2.</span> <span m='2539000'>Any questions before we move on from\
  \ this point?</span> <span m='2543000'>This finished off the proof of this fact\
  \ that we have Theta(n)</span> <span m='2549000'>expected time. We already saw the\
  \ n^2</span> <span m='2552000'>worst-case. All perfectly clear?</span> <span m='2554000'>Good.\
  \ You should go over these</span> <span m='2557000'>proofs. They're intrinsically\
  \ related</span> <span m='2559000'>between randomized quicksort and randomized select.</span>\
  \ <span m='2563000'>Know them in your heart. This is a great algorithm that</span>\
  \ <span m='2567000'>works really well in practice because most of the time you're</span>\
  \ <span m='2572000'>going to split, say, in the middle,</span> <span m='2574000'>somewhere\
  \ between a 1/4 and 3/4 and everything is good.</span> <span m='2580000'>It's extremely\
  \ unlikely that you get the n^2 worst-case.</span> <span m='2583000'>It would have\
  \ to happen with like 1 over n^n probability or</span> <span m='2586000'>something\
  \ really, really small.</span> <span m='2588000'>But I am a theoretician at least.</span>\
  \ <span m='2590000'>And it would be really nice if you could get Theta(n) in the</span>\
  \ <span m='2594000'>worst-case. That would be the cleanest</span> <span m='2596000'>result\
  \ that you could hope for because that's optimal.</span> <span m='2599000'>You cannot\
  \ do better than Theta(n).</span> <span m='2601000'>You've got to look at the elements.</span>\
  \ <span m='2603000'>So, you might ask, can we get rid of this</span> <span m='2605000'>worst-case\
  \ behavior and somehow avoid randomization and</span> <span m='2609000'>guarantee\
  \ Theta(n) worst-case running time?</span> <span m='2613000'>And you can but it's\
  \ a rather nontrivial algorithm.</span> <span m='2619000'>And this is going to be\
  \ one of the most sophisticated that</span> <span m='2625000'>we've seen so far.\
  \ It won't continue to be the</span> <span m='2631000'>most sophisticated algorithm\
  \ we will see, but here it is.</span> <span m='2638000'>Worst-case linear time order\
  \ statistics.</span> <span m='2649000'>And this is an algorithm by several, all\
  \ very famous people,</span> <span m='2662000'>Blum, Floyd, Pratt, Rivest and Tarjan.</span>\
  \ <span m='2672000'>I think I've only met the B and the R and the T.</span> <span\
  \ m='2675000'>Oh, no, I've met Pratt as well. I'm getting close to all the</span>\
  \ <span m='2679000'>authors. This is a somewhat old result,</span> <span m='2682000'>but\
  \ at the time it was a major breakthrough and still is an</span> <span m='2686000'>amazing\
  \ algorithm. Ron Rivest is a professor here.</span> <span m='2690000'>You should\
  \ know him from the R in RSA.</span> <span m='2692000'>When I took my PhD comprehensives\
  \ some time ago,</span> <span m='2696000'>on the cover sheet was a joke question.</span>\
  \ <span m='2700000'>It asked of the authors of the worst-case linear time order</span>\
  \ <span m='2704000'>statistics algorithm, which of them is the most rich?</span>\
  \ <span m='2708000'>Sadly it was not a graded part of the comprehensive exam,</span>\
  \ <span m='2713000'>but it was an amusing question. I won't answer it here because</span>\
  \ <span m='2718000'>we're on tape, [LAUGHTER] but think about it.</span> <span m='2721000'>I\
  \ may not be obvious. Several of them are rich.</span> <span m='2725000'>It's just\
  \ the question of who is the most rich.</span> <span m='2730000'>Anyway, before\
  \ they were rich they came up with this</span> <span m='2733000'>algorithm. They've\
  \ come up with many</span> <span m='2735000'>algorithms since, even after getting\
  \ rich,</span> <span m='2738000'>believe it or not. What we want is a good pivot,</span>\
  \ <span m='2742000'>guaranteed good pivot. Random pivot is going to be</span> <span\
  \ m='2745000'>really good. And so the simplest algorithm</span> <span m='2748000'>is\
  \ just pick a random pivot. It's going to be good with high</span> <span m='2752000'>probability.\
  \ We want to force a good pivot</span> <span m='2755000'>deterministically. And\
  \ the new idea here is we're</span> <span m='2758000'>going to generate it recursively.</span>\
  \ <span m='2762000'>What else could we do but recurse?</span> <span m='2764000'>Well,\
  \ you should know from your recurrences that if we did two</span> <span m='2768000'>recursive\
  \ calls on problems of half the size and we have a</span> <span m='2772000'>linear\
  \ extra work that's the mergesort recurrence,</span> <span m='2776000'>T(n)=2[T(n/2)+Theta(n)].\
  \ You should recite in your</span> <span m='2780000'>sleep. That's n lg n.</span>\
  \ <span m='2781000'>So we cannot recurse on two problems of half the size.</span>\
  \ <span m='2785000'>We've got to do better. Somehow these recursions have</span>\
  \ <span m='2790000'>to add up to strictly less than n.</span> <span m='2792000'>That's\
  \ the magic of this algorithm.</span> <span m='2795000'>So this will just be called\
  \ select instead of rand-select.</span> <span m='2799000'>And it really depends\
  \ on an array, but I will focus on the</span> <span m='2804000'>i-th element that\
  \ we want to select and the size of the array</span> <span m='2808000'>that we want\
  \ to select in. And I am going to write this</span> <span m='2813000'>algorithm\
  \ slightly less formally than randomize-select because</span> <span m='2817000'>it's\
  \ a bit higher level of an algorithm.</span> <span m='2842000'>And let me draw over\
  \ here the picture of the algorithm.</span> <span m='2851000'>The first step is\
  \ sort of the weirdest and it's one of the key</span> <span m='2856000'>ideas. You\
  \ take your elements,</span> <span m='2858000'>and they are in no particular order,\
  \ so instead of drawing</span> <span m='2863000'>them on a line, I am going to draw\
  \ them in a 5</span> <span m='2867000'>by n over 5 grid. Why not?</span> <span m='2869000'>This,\
  \ unfortunately, take a little while to draw,</span> <span m='2874000'>but it will\
  \ take you equally long so I will take my time.</span> <span m='2880000'>It doesn't\
  \ really matter what the width is,</span> <span m='2882000'>but it should be width\
  \ n over 5 so make sure you draw your</span> <span m='2886000'>figure accordingly.\
  \ Width n over 5,</span> <span m='2888000'>but the height should be exactly 5.</span>\
  \ <span m='2890000'>I think I got it right. I can count that high.</span> <span\
  \ m='2893000'>Here is 5. And this should be,</span> <span m='2895000'>well, you\
  \ know, our number may not be divisible</span> <span m='2897000'>by 5, so maybe\
  \ it ends off in sort of an odd way.</span> <span m='2900000'>But what I would like\
  \ is that these chunks should be floor of</span> <span m='2904000'>n over 5. And\
  \ then we will have,</span> <span m='2906000'>at most, four elements left over.</span>\
  \ <span m='2910000'>So I am going to ignore those. They don't really matter.</span>\
  \ <span m='2913000'>It's just an additive constant. Here is my array.</span> <span\
  \ m='2916000'>I just happened to write it in this funny way.</span> <span m='2919000'>And\
  \ I will call these vertical things groups.</span> <span m='2922000'>I would circle\
  \ them, and I did that in my notes,</span> <span m='2925000'>but things get really\
  \ messy if you start circling.</span> <span m='2929000'>This diagram is going to\
  \ get really full, just to warn you.</span> <span m='2933000'>By the end it will\
  \ be almost unintelligible,</span> <span m='2935000'>but there it is. If you are\
  \ really feeling</span> <span m='2940000'>bored, you can draw this a few times.</span>\
  \ <span m='2943000'>And you should draw how it grows.</span> <span m='2946000'>So\
  \ there are the groups, vertical groups of five.</span> <span m='2950000'>Next step.</span>\
  \ <span m='2958000'>The second step is to recurse. This is where things are a bit</span>\
  \ <span m='2964000'>unusual, well, even more unusual.</span> <span m='2968000'>Oops,\
  \ sorry. I really should have had a line</span> <span m='2972000'>between one and\
  \ two so I am going to have to move this down</span> <span m='2977000'>and insert\
  \ it here. I also, in step one,</span> <span m='2980000'>want to find the median\
  \ of each group.</span> <span m='2993000'>What I would like to do is just imagine\
  \ this figure,</span> <span m='2996000'>each of the five elements in each group\
  \ gets reorganized so</span> <span m='2999000'>that the middle one is the median.</span>\
  \ <span m='3002000'>So I am going to call these the medians of each group.</span>\
  \ <span m='3005000'>I have five elements so the median is right in the middle.</span>\
  \ <span m='3010000'>There are two elements less than the median,</span> <span m='3013000'>two\
  \ elements greater than the median.</span> <span m='3015000'>Again, we're assuming\
  \ all elements are distinct.</span> <span m='3019000'>So there they are. I compute\
  \ them.</span> <span m='3021000'>How long does that take me? N over five groups,</span>\
  \ <span m='3024000'>each with five elements, compute the median of each one?</span>\
  \ <span m='3030000'>Sorry? Yeah, 2 times n over 5.</span> <span m='3032000'>It's\
  \ theta n, that's all I need to know.</span> <span m='3034000'>I mean, you're counting\
  \ comparisons, which is good.</span> <span m='3038000'>It's definitely Theta(n).\
  \ The point is within each group,</span> <span m='3042000'>I only have to do a constant\
  \ number of comparisons because</span> <span m='3046000'>it's a constant number\
  \ of elements.</span> <span m='3048000'>It doesn't matter. You could use randomize\
  \ select</span> <span m='3051000'>for all I care. No matter what you do,</span>\
  \ <span m='3054000'>it can only take a constant number of comparisons.</span> <span\
  \ m='3059000'>As long as you don't make a comparison more than once.</span> <span\
  \ m='3063000'>So this is easy. You could sort the five numbers</span> <span m='3067000'>and\
  \ then look at the third one, it doesn't matter because there</span> <span m='3072000'>are\
  \ only five of them. That's one nifty idea.</span> <span m='3076000'>Already we\
  \ have some elements that are sort of vaguely in the</span> <span m='3081000'>middle\
  \ but just of the group. And we've only done linear</span> <span m='3085000'>work.\
  \ So doing well so far.</span> <span m='3089000'>Now we get to the second step,\
  \ which I started to write</span> <span m='3093000'>before, where we recurse.</span>\
  \ <span m='3118000'>So the next idea is, well, we have these floor over</span> <span\
  \ m='3121000'>n over 5 medians. I am going to compute the</span> <span m='3124000'>median\
  \ of those medians. I am imagining that I</span> <span m='3127000'>rearranged these.\
  \ And, unfortunately,</span> <span m='3129000'>it's an even number, there are six\
  \ of them,</span> <span m='3131000'>but I will rearrange so that this guy, I have\
  \ drawn in a</span> <span m='3135000'>second box, is the median of these elements\
  \ so that these two</span> <span m='3138000'>elements are strictly less than this\
  \ guy, these three elements</span> <span m='3142000'>are strictly greater than this\
  \ guy.</span> <span m='3144000'>Now, that doesn't directly tell me anything, it\
  \ would seem,</span> <span m='3147000'>about any of the elements out here.</span>\
  \ <span m='3151000'>We will come back to that. In fact, it does tell us about</span>\
  \ <span m='3155000'>some of the elements. But right now this element is</span> <span\
  \ m='3158000'>just the median of these guys. Each of these guys is a median</span>\
  \ <span m='3162000'>of five elements. That's all we know.</span> <span m='3165000'>If\
  \ we do that recursively, this is going to take T of n</span> <span m='3169000'>over\
  \ 5 time. So far so good.</span> <span m='3171000'>We can afford a recursion on\
  \ a problem of size n over 5 and</span> <span m='3175000'>linear work. We know that\
  \ works out to</span> <span m='3178000'>linear time. But there is more.</span> <span\
  \ m='3180000'>We're obviously not done yet.</span> <span m='3190000'>The next step\
  \ is x is our partition element.</span> <span m='3192000'>We partition there. The\
  \ rest of the algorithm is</span> <span m='3195000'>just like randomized partition,\
  \ so we're going to define k to</span> <span m='3199000'>be the rank of x. And this\
  \ can be done,</span> <span m='3201000'>I mean it's n minus r plus 1 or whatever,\
  \ but I'm not going to</span> <span m='3205000'>write out how to do that because\
  \ we're at a higher level here.</span> <span m='3210000'>But it can be done. And\
  \ then we have the three-way</span> <span m='3214000'>branching. So if i happens\
  \ to equal k</span> <span m='3217000'>we're happy. The pivot element is the</span>\
  \ <span m='3221000'>element we're looking for, but more likely i is either</span>\
  \ <span m='3226000'>less than k or it is bigger than k.</span> <span m='3229000'>And\
  \ then we make the appropriate recursive call,</span> <span m='3233000'>so here\
  \ we recursively select the i-th smallest element --</span> <span m='3248000'>--\
  \ in the lower part of the array.</span> <span m='3251000'>Left of the partition\
  \ element. Otherwise, we recursively</span> <span m='3256000'>select the i minus\
  \ k-th smallest element in the upper part of the</span> <span m='3262000'>array.\
  \ I am writing this at a high</span> <span m='3265000'>level because we've already\
  \ seen it.</span> <span m='3270000'>All of this is the same as the last couple steps\
  \ of randomized</span> <span m='3276000'>select.</span> <span m='3285000'>That is\
  \ the algorithm. The real question is why does</span> <span m='3288000'>it work?\
  \ Why is this linear time?</span> <span m='3290000'>The first question is what's\
  \ the recurrence?</span> <span m='3293000'>We cannot quite write it down yet because\
  \ we don't know how</span> <span m='3296000'>big these recursive subproblems could\
  \ be.</span> <span m='3300000'>We're going to either recurse in the lower part or\
  \ the upper</span> <span m='3303000'>part, that's just like before. If we're unlucky\
  \ and we have a</span> <span m='3307000'>split of like zero to n minus one, this\
  \ is going to be a</span> <span m='3311000'>quadratic time algorithm. The claim\
  \ is that this</span> <span m='3314000'>partition element is guaranteed to be pretty\
  \ good and good</span> <span m='3318000'>enough. The running time of this thing</span>\
  \ <span m='3321000'>will be T of something times n, and we don't know what the</span>\
  \ <span m='3324000'>something is yet. How big could it be?</span> <span m='3327000'>Well,\
  \ I could ask you. But we're sort of indirect here</span> <span m='3332000'>so I\
  \ will tell you. We have already a recursive</span> <span m='3334000'>call of T\
  \ of n over 5. It better be that whatever</span> <span m='3338000'>constant, so\
  \ it's going to be something times n,</span> <span m='3341000'>it better be that\
  \ that constant is strictly less than 4/5.</span> <span m='3344000'>If it's equal\
  \ to 4/5 then you're not splitting up the</span> <span m='3348000'>problem enough\
  \ to get an n lg n running time.</span> <span m='3351000'>If it's strictly less\
  \ than 4/5 then you're reducing the problem</span> <span m='3355000'>by at least\
  \ a constant factor. In the sense if you add up all</span> <span m='3359000'>the\
  \ recursive subproblems, n over 5 and something times n,</span> <span m='3363000'>you\
  \ get something that is a constant strictly less than one</span> <span m='3367000'>times\
  \ n. That forces the work to be</span> <span m='3369000'>geometric. If it's geometric\
  \ you're going</span> <span m='3372000'>to get linear time. So this is intuition\
  \ but it's</span> <span m='3375000'>the right intuition. Whenever you're aiming\
  \ for</span> <span m='3378000'>linear time keep that in mind. If you're doing a</span>\
  \ <span m='3381000'>divide-and-conquer, you've got to get the total</span> <span\
  \ m='3384000'>subproblem size to be some constant less than one times n.</span>\
  \ <span m='3387000'>That will work. OK, so we've got to work out</span> <span m='3392000'>this\
  \ constant here. And we're going to use this</span> <span m='3397000'>figure, which\
  \ so far looks surprisingly uncluttered.</span> <span m='3402000'>Now we will make\
  \ it cluttered. What I would like to do is draw</span> <span m='3408000'>an arrow\
  \ between two vertices, two points, elements,</span> <span m='3413000'>whatever\
  \ you want to call them. Let's call them a and b.</span> <span m='3420000'>And I\
  \ want to orient the arrow so it points to a larger value,</span> <span m='3424000'>so\
  \ this means that a is less than b.</span> <span m='3426000'>This is notation just\
  \ for the diagram.</span> <span m='3429000'>And so this element, I am going to write\
  \ down what I</span> <span m='3433000'>know. This element is the median of</span>\
  \ <span m='3435000'>these five elements. I will suppose that it is drawn</span>\
  \ <span m='3439000'>so that these elements are larger than the median,</span> <span\
  \ m='3442000'>these elements are smaller than the median.</span> <span m='3445000'>Therefore,\
  \ I have arrows like this.</span> <span m='3448000'>Here is where I wish I had some\
  \ colored chalk.</span> <span m='3453000'>This is just stating this guy is in the\
  \ middle of those five</span> <span m='3456000'>elements. I know that in every single</span>\
  \ <span m='3459000'>column.</span> <span m='3475000'>Here is where the diagram starts\
  \ to get messy.</span> <span m='3478000'>I am not done yet. Now, we also know that\
  \ this</span> <span m='3481000'>element is the median of the medians.</span> <span\
  \ m='3483000'>Of all the squared elements, this guy is the middle.</span> <span\
  \ m='3486000'>And I will draw it so that these are the ones smaller than</span>\
  \ <span m='3490000'>the median, these are the ones larger than the median.</span>\
  \ <span m='3493000'>I mean the algorithm cannot do this.</span> <span m='3495000'>It\
  \ doesn't necessarily know how all this works.</span> <span m='3498000'>I guess\
  \ it could, but this is just for analysis</span> <span m='3500000'>purposes. We\
  \ know this guy is bigger than</span> <span m='3503000'>that one and bigger than\
  \ that one.</span> <span m='3505000'>We don't directly know about the other elements.</span>\
  \ <span m='3509000'>We just know that that one is bigger than both of those and</span>\
  \ <span m='3513000'>this guy is smaller than these. Now, that is as messy as the</span>\
  \ <span m='3517000'>figure will get. Now, the nice thing about less</span> <span\
  \ m='3520000'>than is that it's a transitive relation.</span> <span m='3523000'>If\
  \ I have a directed path in this graph, I know that this</span> <span m='3527000'>element\
  \ is strictly less than that element because this is</span> <span m='3531000'>less\
  \ than that one and this is less than that one.</span> <span m='3534000'>Even though\
  \ directly I only know within a column and within</span> <span m='3539000'>this\
  \ middle row, I actually know that this</span> <span m='3542000'>element -- This\
  \ is x, by the way.</span> <span m='3545000'>This element is larger than all of\
  \ these elements because it's</span> <span m='3550000'>larger than this one and\
  \ this one and each of these is larger</span> <span m='3555000'>than all of those\
  \ by these arrows.</span> <span m='3557000'>I also know that all of these elements\
  \ in this rectangle here,</span> <span m='3562000'>and you don't have to do this\
  \ but I will make the background</span> <span m='3567000'>even more cluttered. All\
  \ of these elements in this</span> <span m='3572000'>rectangle are greater than\
  \ or equal to this one and all of the</span> <span m='3577000'>elements in this\
  \ rectangle are less than or equal to x.</span> <span m='3582000'>Now, how many\
  \ are there? Well, this is roughly halfway</span> <span m='3587000'>along the set\
  \ of groups and this is 3/5 of these columns.</span> <span m='3592000'>So what we\
  \ get is that there are at least --</span> <span m='3597000'>We have n over 5 groups\
  \ and we have half of the groups that</span> <span m='3603554'>we're looking at\
  \ here roughly, so let's call that floor of n</span> <span m='3610222'>over 2, and\
  \ then within each group we have three elements.</span> <span m='3616664'>So we\
  \ have at least 3 times floor of floor of n over 5 over</span> <span m='3623219'>2\
  \ n floor elements that are less than or equal to x.</span> <span m='3630000'>And\
  \ we have the same that are greater than or equal to x.</span> <span m='3636222'>Let\
  \ me simplify this a little bit more.</span> <span m='3640444'>I can also give you\
  \ some more justification,</span> <span m='3645222'>and we drew the picture, but\
  \ just for why this is true.</span> <span m='3651222'>We have at least n over 5\
  \ over 2 group medians that are less</span> <span m='3657777'>than or equal to x.\
  \ This is the argument we use.</span> <span m='3662622'>We have half of the group\
  \ medians are less than or equal</span> <span m='3665809'>to x because x is the\
  \ median of the group median,</span> <span m='3668590'>so that is no big surprise.\
  \ This is almost an equality but</span> <span m='3671892'>we're making floors so\
  \ it's greater than or equal to.</span> <span m='3674905'>And then, for each group\
  \ median, we know that there are</span> <span m='3678034'>three elements there that\
  \ are less than or equal to that group</span> <span m='3681568'>median. So, by transitivity,</span>\
  \ <span m='3683133'>they're also less than or equal to x.</span> <span m='3685218'>We\
  \ get this number times three. This is actually just floor of</span> <span m='3690664'>n\
  \ over 10. I was being unnecessarily</span> <span m='3693773'>complicated there,\
  \ but that is where it came from.</span> <span m='3698126'>What we know is that\
  \ this thing is now at least 3 times n over</span> <span m='3703544'>10, which is\
  \ roughly 3/10 of elements are in one side.</span> <span m='3708252'>In fact, at\
  \ least 3/10 of the elements are in each side.</span> <span m='3713137'>Therefore,\
  \ each side has at most 7/10 elements roughly.</span> <span m='3719000'>So the number\
  \ here will be 7/10.</span> <span m='3721214'>And, if I'm lucky, 7/10 plus 1/5 is\
  \ strictly less</span> <span m='3724642'>than one. I believe it is,</span> <span\
  \ m='3726428'>but I have trouble working with tenths.</span> <span m='3729142'>I\
  \ can only handle powers of two.</span> <span m='3731357'>What we're going to use\
  \ is a minor simplification,</span> <span m='3734857'>which just barely still works,\
  \ is a little bit easier to think</span> <span m='3739214'>about. It's mainly to\
  \ get rid of this</span> <span m='3741785'>floor because the floor is annoying.</span>\
  \ <span m='3744285'>And we don't really have a sloppiness lemma that applies</span>\
  \ <span m='3748214'>here. It turns out if n is</span> <span m='3751463'>sufficiently\
  \ large, 3 times floor of n over 10 is</span> <span m='3754975'>greater than or\
  \ equal to 1/4. Quarters I can handle.</span> <span m='3758707'>The claim is that\
  \ each group has size at least 1/4,</span> <span m='3762365'>therefore each group\
  \ has size at most 3/4 because there's a</span> <span m='3766609'>quarter on the\
  \ side. This will be 3/4.</span> <span m='3769317'>And I can definitely tell that\
  \ 1/5 is less than 1/4.</span> <span m='3773048'>This is going to add up to something\
  \ strictly less than one</span> <span m='3777292'>and then it will work. How is\
  \ my time?</span> <span m='3781292'>Good. At this point,</span> <span m='3782929'>the\
  \ rest of the analysis is easy.</span> <span m='3785686'>How the heck you would\
  \ come up with this algorithm,</span> <span m='3789993'>you realize that this is\
  \ clearly a really good choice for</span> <span m='3794818'>finding a partition\
  \ element, just barely good enough that</span> <span m='3799643'>both recursions\
  \ add up to linear time.</span> <span m='3802830'>Well, that's why it took so many\
  \ famous people.</span> <span m='3808000'>Especially in quizzes, but I think in\
  \ general this</span> <span m='3810780'>class, you won't have to come up with an\
  \ algorithm this clever</span> <span m='3814241'>because you can just use this algorithm\
  \ to find the median.</span> <span m='3817531'>And the median is a really good partition\
  \ element.</span> <span m='3820312'>Now that you know this algorithm, now that we're\
  \ beyond</span> <span m='3823375'>1973, you don't need to know how to do this.</span>\
  \ <span m='3825815'>I mean you should know how this algorithm works,</span> <span\
  \ m='3828482'>but you don't need to do this in another algorithm because you</span>\
  \ <span m='3831943'>can just say run this algorithm, you will get the median in</span>\
  \ <span m='3835234'>linear time, and then you can partition to the left and the</span>\
  \ <span m='3838524'>right. And then the left and the right</span> <span m='3842225'>will\
  \ have exactly equal size. Great.</span> <span m='3844737'>This is a really powerful\
  \ subroutine.</span> <span m='3847321'>You could use this all over the place, and\
  \ you will on Friday.</span> <span m='3851700'>Have I analyzed the running time\
  \ pretty much?</span> <span m='3854858'>The first step is linear. The second step\
  \ is T of n over</span> <span m='3860027'>I didn't write it, is linear.</span> <span\
  \ m='3862037'>And then the last step is just a recursive call.</span> <span m='3865410'>And\
  \ now we know that this is 3/4.</span> <span m='3874000'>I get this recurrence.\
  \ T of n is, I'll say at most,</span> <span m='3880000'>T of n over 5 plus T of\
  \ 3/4n. You could have also used 7/10.</span> <span m='3887079'>It would give the\
  \ same answer, but you would also need a floor</span> <span m='3894400'>so we won't\
  \ do that. I claim that this is linear.</span> <span m='3901000'>How should I prove\
  \ it? Substitution.</span> <span m='3912000'>Claim that T of n is at most again\
  \ c times n,</span> <span m='3915901'>that will be enough. Proof is by substitution.</span>\
  \ <span m='3919891'>Again, we assume this is true for smaller n.</span> <span m='3923704'>And\
  \ want to prove it for n. We have T of n is at most this</span> <span m='3928758'>thing.\
  \ T of n over 5.</span> <span m='3931489'>And by induction, because n of 5 is smaller\
  \ than</span> <span m='3936489'>n, we know that this is at most c.</span> <span\
  \ m='3940000'>Let me write it as c over 5 times n.</span> <span m='3943723'>Sure,\
  \ why not. Then we have here 3/4cn.</span> <span m='3947765'>And then we have a\
  \ linear term. Now, unfortunately,</span> <span m='3953085'>I have to deal with\
  \ things that are not powers of two.</span> <span m='3960000'>I will cheat and look\
  \ at my notes.</span> <span m='3962447'>This is also known as 19/20 times c times\
  \ n plus theta n.</span> <span m='3966599'>And the point is just that this is strictly\
  \ less than one.</span> <span m='3970826'>Because it's strictly less than one, I\
  \ can write this as one</span> <span m='3975202'>times c of n minus some constant,\
  \ here it happens to be</span> <span m='3979206'>1/20, as long as I have something\
  \ left over here,</span> <span m='3982766'>1/20 times c times n. Then I have this\
  \ annoying theta</span> <span m='3986622'>n term which I want to get rid of because\
  \ I want this to be</span> <span m='3990923'>nonnegative. But it is nonnegative,</span>\
  \ <span m='3994783'>as long as I set c to be really, really large,</span> <span\
  \ m='3998432'>at least 20 times whatever constant is here.</span> <span m='4001918'>So\
  \ this is at most c times n for c sufficiently large.</span> <span m='4006216'>And,\
  \ oh, by the way, if n is less than or equal to</span> <span m='4010189'>50, which\
  \ we used up here, then T of n is a constant,</span> <span m='4014404'>it doesn't\
  \ really matter what you do, and T of n is at most c</span> <span m='4019270'>times\
  \ n for c sufficiently large.</span> <span m='4023000'>That proves this claim. Of\
  \ course, the constant here is</span> <span m='4026017'>pretty damn big. It depends\
  \ exactly what the</span> <span m='4028421'>constants and the running times are,\
  \ which depends on your</span> <span m='4031606'>machine, but practically this algorithm\
  \ is not so hot because</span> <span m='4034960'>the constants are pretty big. Even\
  \ though this element is</span> <span m='4038089'>guaranteed to be somewhere vaguely\
  \ in the middle,</span> <span m='4040772'>and even though these recursions add up\
  \ to strictly</span> <span m='4043566'>less than n and it's geometric, it's geometric\
  \ because the</span> <span m='4046752'>problem is reducing by at least a factor\
  \ of 19/20 each time.</span> <span m='4051000'>So it actually takes a while for\
  \ the problem to get really</span> <span m='4054742'>small. Practically you probably\
  \ don't</span> <span m='4057106'>want to use this algorithm unless you cannot somehow\
  \ flip</span> <span m='4060782'>coins. The randomized algorithm works</span> <span\
  \ m='4063146'>really, really fast. Theoretically this is your</span> <span m='4066166'>dream,\
  \ the best you could hope for because it's linear time and</span> <span m='4070237'>you\
  \ need linear time as guaranteed linear time.</span> <span m='4073257'>I will mention,\
  \ before we end,</span> <span m='4075161'>an exercise.</span> <span m='4083000'>Why\
  \ did we use groups of five? Why not groups of three?</span> <span m='4086375'>As\
  \ you might guess, the answer is because it</span> <span m='4089062'>doesn't work\
  \ with groups of three.</span> <span m='4091125'>But it's quite constructive to\
  \ find out why.</span> <span m='4093812'>If you work through this math with groups\
  \ of three instead of</span> <span m='4097562'>groups of five, you will find that\
  \ you don't</span> <span m='4100250'>quite get the problem reduction that you need.</span>\
  \ <span m='4103062'>Five is the smallest number for which this works.</span> <span\
  \ m='4107000'>It would work with seven, but theoretically not any</span> <span m='4110176'>better\
  \ than a constant factor. Any questions?</span> <span m='4112973'>All right. Then\
  \ recitation Friday.</span> <span m='4115069'>Homework lab Sunday. Problem set due\
  \ Monday.</span> <span m='4117801'>Quiz one in two weeks.</span> </p>"
type: course
uid: 6bf801941af370fec4ee856e8e874bcc

---
None